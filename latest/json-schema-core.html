<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>JSON Schema: A Media Type for Describing JSON Documents</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Overview"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Validation"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Annotation"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Hypermedia and Linking"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Definitions"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 JSON Document"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Instance"/>
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Instance Data Model"/>
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Instance Media Types"/>
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Instance Equality"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 JSON Schema Documents"/>
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 JSON Schema Values and Keywords"/>
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 JSON Schema Vocabularies"/>
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Root Schema and Subschemas"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Fragment Identifiers"/>
<link href="#rfc.section.6" rel="Chapter" title="6 General Considerations"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Range of JSON Values"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Programming Language Independence"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Mathematical Integers"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Extending JSON Schema"/>
<link href="#rfc.section.7" rel="Chapter" title="7 The &quot;$schema&quot; Keyword"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Base URI and Dereferencing"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Initial Base URI"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 The &quot;$id&quot; Keyword"/>
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 Identifying the root schema"/>
<link href="#rfc.section.8.2.2" rel="Chapter" title="8.2.2 Changing the base URI within a schema file"/>
<link href="#rfc.section.8.2.3" rel="Chapter" title="8.2.3 Location-independent identifiers"/>
<link href="#rfc.section.8.2.4" rel="Chapter" title="8.2.4 Schema identification examples"/>
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Schema References With &quot;$ref&quot;"/>
<link href="#rfc.section.8.3.1" rel="Chapter" title="8.3.1 Loading a referenced schema"/>
<link href="#rfc.section.8.3.2" rel="Chapter" title="8.3.2 Dereferencing"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Comments With &quot;$comment&quot;"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Usage for Hypermedia"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Linking to a Schema"/>
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Identifying a Schema via a Media Type Parameter"/>
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Usage Over HTTP"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Security Considerations"/>
<link href="#rfc.section.12" rel="Chapter" title="12 IANA Considerations"/>
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 application/schema+json"/>
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 application/schema-instance+json"/>
<link href="#rfc.references" rel="Chapter" title="13 References"/>
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Acknowledgments"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B ChangeLog"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Wright, A., Ed. and H. Andrews, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-handrews-json-schema-01" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-3-19" />
  <meta name="dct.abstract" content="JSON Schema defines the media type &quot;application/schema+json&quot;, a JSON-based format for describing the structure of JSON data.  JSON Schema asserts what a JSON document must look like, ways to extract information from it, and how to interact with it.  The &quot;application/schema-instance+json&quot; media type provides additional feature-rich integration with &quot;application/schema+json&quot; beyond what can be offered for &quot;application/json&quot; documents.  " />
  <meta name="description" content="JSON Schema defines the media type &quot;application/schema+json&quot;, a JSON-based format for describing the structure of JSON data.  JSON Schema asserts what a JSON document must look like, ways to extract information from it, and how to interact with it.  The &quot;application/schema-instance+json&quot; media type provides additional feature-rich integration with &quot;application/schema+json&quot; beyond what can be offered for &quot;application/json&quot; documents.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Internet Engineering Task Force</td>
  <td class="right">A. Wright, Ed.</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right"></td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">H. Andrews, Ed.</td>
</tr>
<tr>
  <td class="left">Expires: September 20, 2018</td>
  <td class="right">Cloudflare, Inc.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">March 19, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">JSON Schema: A Media Type for Describing JSON Documents<br />
  <span class="filename">draft-handrews-json-schema-01</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>JSON Schema defines the media type "application/schema+json", a JSON-based format for describing the structure of JSON data.  JSON Schema asserts what a JSON document must look like, ways to extract information from it, and how to interact with it.  The "application/schema-instance+json" media type provides additional feature-rich integration with "application/schema+json" beyond what can be offered for "application/json" documents.  </p>
<h1>
  <a>Note to Readers</a>
</h1>
<p>The issues list for this draft can be found at <span>&lt;</span><a href="https://github.com/json-schema-org/json-schema-spec/issues">https://github.com/json-schema-org/json-schema-spec/issues</a><span>&gt;</span>.  </p>
<p>For additional information, see <span>&lt;</span><a href="http://json-schema.org/">http://json-schema.org/</a><span>&gt;</span>.  </p>
<p>To provide feedback, use this issue tracker, the communication methods listed on the homepage, or email the document editors.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 20, 2018.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Conventions and Terminology</a></li>
<li>3.   <a href="#rfc.section.3">Overview</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Validation</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Annotation</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Hypermedia and Linking</a></li>
</ul><li>4.   <a href="#rfc.section.4">Definitions</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">JSON Document</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Instance</a></li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Instance Data Model</a></li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Instance Media Types</a></li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Instance Equality</a></li>
</ul><li>4.3.   <a href="#rfc.section.4.3">JSON Schema Documents</a></li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">JSON Schema Values and Keywords</a></li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">JSON Schema Vocabularies</a></li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Root Schema and Subschemas</a></li>
</ul></ul><li>5.   <a href="#rfc.section.5">Fragment Identifiers</a></li>
<li>6.   <a href="#rfc.section.6">General Considerations</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Range of JSON Values</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Programming Language Independence</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Mathematical Integers</a></li>
<li>6.4.   <a href="#rfc.section.6.4">Extending JSON Schema</a></li>
</ul><li>7.   <a href="#rfc.section.7">The "$schema" Keyword</a></li>
<li>8.   <a href="#rfc.section.8">Base URI and Dereferencing</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Initial Base URI</a></li>
<li>8.2.   <a href="#rfc.section.8.2">The "$id" Keyword</a></li>
<ul><li>8.2.1.   <a href="#rfc.section.8.2.1">Identifying the root schema</a></li>
<li>8.2.2.   <a href="#rfc.section.8.2.2">Changing the base URI within a schema file</a></li>
<li>8.2.3.   <a href="#rfc.section.8.2.3">Location-independent identifiers</a></li>
<li>8.2.4.   <a href="#rfc.section.8.2.4">Schema identification examples</a></li>
</ul><li>8.3.   <a href="#rfc.section.8.3">Schema References With "$ref"</a></li>
<ul><li>8.3.1.   <a href="#rfc.section.8.3.1">Loading a referenced schema</a></li>
<li>8.3.2.   <a href="#rfc.section.8.3.2">Dereferencing</a></li>
</ul></ul><li>9.   <a href="#rfc.section.9">Comments With "$comment"</a></li>
<li>10.   <a href="#rfc.section.10">Usage for Hypermedia</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Linking to a Schema</a></li>
<li>10.2.   <a href="#rfc.section.10.2">Identifying a Schema via a Media Type Parameter</a></li>
<li>10.3.   <a href="#rfc.section.10.3">Usage Over HTTP</a></li>
</ul><li>11.   <a href="#rfc.section.11">Security Considerations</a></li>
<li>12.   <a href="#rfc.section.12">IANA Considerations</a></li>
<ul><li>12.1.   <a href="#rfc.section.12.1">application/schema+json</a></li>
<li>12.2.   <a href="#rfc.section.12.2">application/schema-instance+json</a></li>
</ul><li>13.   <a href="#rfc.references">References</a></li>
<ul><li>13.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Acknowledgments</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">ChangeLog</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">JSON Schema is a JSON media type for defining the structure of JSON data. JSON Schema is intended to define validation, documentation, hyperlink navigation, and interaction control of JSON data.  </p>
<p id="rfc.section.1.p.2">This specification defines JSON Schema core terminology and mechanisms, including pointing to another JSON Schema by reference, dereferencing a JSON Schema reference, and specifying the vocabulary being used.  </p>
<p id="rfc.section.1.p.3">Other specifications define the vocabularies that perform assertions about validation, linking, annotation, navigation, and interaction.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> Conventions and Terminology</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.  </p>
<p id="rfc.section.2.p.2">The terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array", "number", "string", "boolean", "true", "false", and "null" in this document are to be interpreted as defined in <a href="#RFC7159">RFC 7159</a> <cite title="NONE">[RFC7159]</cite>.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> Overview</h1>
<p id="rfc.section.3.p.1">This document proposes a new media type "application/schema+json" to identify a JSON Schema for describing JSON data.  It also proposes a further optional media type, "application/schema-instance+json", to provide additional integration features.  JSON Schemas are themselves JSON documents.  This, and related specifications, define keywords allowing authors to describe JSON data in several ways.  </p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> Validation</h1>
<p id="rfc.section.3.1.p.1">JSON Schema describes the structure of a JSON document (for instance, required properties and length limitations).  Applications can use this information to validate instances (check that constraints are met), or inform interfaces to collect user input such that the constraints are satisfied.  </p>
<p id="rfc.section.3.1.p.2">Validation behaviour and keywords are specified in <a href="#json-schema-validation">a separate document</a> <cite title="NONE">[json-schema-validation]</cite>.  </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> Annotation</h1>
<p id="rfc.section.3.2.p.1">JSON Schema can annotate an instance with information, whenever the instance validates against the schema object containing the annotation, and all of its parent schema objects.  </p>
<p id="rfc.section.3.2.p.2">Detailed annotation behavior, along with a small set of basic annotation keywords are defined in <a href="#json-schema-validation">the validation specification</a> <cite title="NONE">[json-schema-validation]</cite>.  </p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> Hypermedia and Linking</h1>
<p id="rfc.section.3.3.p.1">JSON Hyper-Schema describes the hypertext structure of a JSON document.  This includes link relations from the instance to other resources, interpretation of instances as multimedia data, and submission data required to use an API.  </p>
<p id="rfc.section.3.3.p.2">Hyper-schema behaviour and keywords are specified in <a href="#json-hyper-schema">a separate document</a> <cite title="NONE">[json-hyper-schema]</cite>.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> Definitions</h1>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> JSON Document</h1>
<p id="rfc.section.4.1.p.1">A JSON document is an information resource (series of octets) described by the application/json media type.  </p>
<p id="rfc.section.4.1.p.2">In JSON Schema, the terms "JSON document", "JSON text", and "JSON value" are interchangeable because of the data model it defines.  </p>
<p id="rfc.section.4.1.p.3">JSON Schema is only defined over JSON documents. However, any document or memory structure that can be parsed into or processed according to the JSON Schema data model can be interpreted against a JSON Schema, including media types like <a href="#RFC7049">CBOR</a> <cite title="NONE">[RFC7049]</cite>.  </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> Instance</h1>
<p id="rfc.section.4.2.p.1">A JSON document to which a schema is applied is known as an "instance".  </p>
<h1 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a> Instance Data Model</h1>
<p id="rfc.section.4.2.1.p.1">JSON Schema interprets documents according to a data model. A JSON value interpreted according to this data model is called an "instance".  </p>
<p id="rfc.section.4.2.1.p.2">An instance has one of six primitive types, and a range of possible values depending on the type: </p>

<dl>
  <dt>null:</dt>
  <dd style="margin-left: 8">A JSON "null" production</dd>
  <dt>boolean:</dt>
  <dd style="margin-left: 8">A "true" or "false" value, from the JSON "true" or "false" productions</dd>
  <dt>object:</dt>
  <dd style="margin-left: 8">An unordered set of properties mapping a string to an instance, from the JSON "object" production</dd>
  <dt>array:</dt>
  <dd style="margin-left: 8">An ordered list of instances, from the JSON "array" production</dd>
  <dt>number:</dt>
  <dd style="margin-left: 8">An arbitrary-precision, base-10 decimal number value, from the JSON "number" production</dd>
  <dt>string:</dt>
  <dd style="margin-left: 8">A string of Unicode code points, from the JSON "string" production</dd>
</dl>

<p> </p>
<p id="rfc.section.4.2.1.p.3">Whitespace and formatting concerns, including different lexical representations of numbers that are equal within the data model, are thus outside the scope of JSON Schema.  JSON Schema <a href="#vocabulary">vocabularies</a> <cite title="NONE">[vocabulary]</cite> that wish to work with such differences in lexical representations SHOULD define keywords to precisely interpret formatted strings within the data model rather than relying on having the original JSON representation Unicode characters available.  </p>
<p id="rfc.section.4.2.1.p.4">Since an object cannot have two properties with the same key, behavior for a JSON document that tries to define two properties (the "member" production) with the same key (the "string" production) in a single object is undefined.  </p>
<p id="rfc.section.4.2.1.p.5">Note that JSON Schema vocabularies are free to define their own extended type system.  This should not be confused with the core data model types defined here.  As an example, "integer" is a reasonable type for a vocabulary to define as a value for a keyword, but the data model makes no distinction between integers and other numbers.  </p>
<h1 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a> Instance Media Types</h1>
<p id="rfc.section.4.2.2.p.1">JSON Schema is designed to fully work with "application/json" documents, as well as media types using the "+json" structured syntax suffix.  </p>
<p id="rfc.section.4.2.2.p.2">Some functionality that is useful for working with schemas is defined by each media type, namely media type parameters and URI fragment identifier syntax and semantics.  These features are useful in content negotiation and in calculating URIs for specific locations within an instance, respectively.  </p>
<p id="rfc.section.4.2.2.p.3">This specification defines the "application/schema-instance+json" media type in order to allow instance authors to take full advantage of parameters and fragment identifiers for these purposes.  </p>
<h1 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3.</a> Instance Equality</h1>
<p id="rfc.section.4.2.3.p.1">Two JSON instances are said to be equal if and only if they are of the same type and have the same value according to the data model. Specifically, this means: </p>

<ul class="empty">
  <li>both are null; or</li>
  <li>both are true; or</li>
  <li>both are false; or</li>
  <li>both are strings, and are the same codepoint-for-codepoint; or</li>
  <li>both are numbers, and have the same mathematical value; or</li>
  <li>both are arrays, and have an equal value item-for-item; or</li>
  <li>both are objects, and each property in one has exactly one property with a key equal to the other's, and that other property has an equal value.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.3.p.2">Implied in this definition is that arrays must be the same length, objects must have the same number of members, properties in objects are unordered, there is no way to define multiple properties with the same key, and mere formatting differences (indentation, placement of commas, trailing zeros) are insignificant.  </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> JSON Schema Documents</h1>
<p id="rfc.section.4.3.p.1">A JSON Schema document, or simply a schema, is a JSON document used to describe an instance.  A schema is itself interpreted as an instance, but SHOULD always be given the media type "application/schema+json" rather than "application/schema-instance+json".  The "application/schema+json" media type is defined to offer a superset of the media type parameter and fragment identifier syntax and semantics provided by "application/schema-instance+json".  </p>
<h1 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1.</a> JSON Schema Values and Keywords</h1>
<p id="rfc.section.4.3.1.p.1">A JSON Schema MUST be an object or a boolean.  </p>
<p id="rfc.section.4.3.1.p.2">Object properties that are applied to the instance are called keywords, or schema keywords.  Broadly speaking, keywords fall into one or both of two categories: </p>

<dl>
  <dt>assertions:</dt>
  <dd style="margin-left: 8">produce a boolean result when applied to an instance </dd>
  <dt>annotations:</dt>
  <dd style="margin-left: 8">attach information to an instance for application use </dd>
</dl>

<p> </p>
<p id="rfc.section.4.3.1.p.3">Keywords may fall into either or both categories.  Extension keywords, meaning those defined outside of this document and its companions, are free to define other behaviors as well.  </p>
<p id="rfc.section.4.3.1.p.4">The boolean schema values "true" and "false" are trivial assertions that always return themselves regardless of the instance value.  As an example, in terms of the validation vocabulary, boolean schemas are equivalent to the following behaviors: </p>

<dl>
  <dt>true:</dt>
  <dd style="margin-left: 8">Always passes validation, as if the empty schema {} </dd>
  <dt>false:</dt>
  <dd style="margin-left: 8">Always fails validation, as if the schema { "not":{} } </dd>
</dl>

<p> </p>
<p id="rfc.section.4.3.1.p.5">A JSON Schema MAY contain properties which are not schema keywords.  Unknown keywords SHOULD be ignored.  </p>
<p id="rfc.section.4.3.1.p.6">An empty schema is a JSON Schema with no properties, or only unknown properties.  </p>
<h1 id="rfc.section.4.3.2"><a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#vocabulary" id="vocabulary">JSON Schema Vocabularies</a></h1>
<p id="rfc.section.4.3.2.p.1">A JSON Schema vocabulary is a set of keywords defined for a particular purpose.  The vocabulary specifies the meaning of its keywords as assertions, annotations, and/or any vocabulary-defined keyword category.  The two companion standards to this document each define a vocabulary: One for instance validation, and one for hypermedia annotations.  Vocabularies are the primary mechanism for extensibility within the JSON Schema media type.  </p>
<p id="rfc.section.4.3.2.p.2">Vocabularies may be defined by any entity.  Vocabulary authors SHOULD take care to avoid keyword name collisions if the vocabulary is intended for broad use, and potentially combined with other vocabularies.  JSON Schema does not provide any formal namespacing system, but also does not constrain keyword names, allowing for any number of namespacing approaches.  </p>
<p id="rfc.section.4.3.2.p.3">Vocabularies may build on each other, such as by defining the behavior of their keywords with respect to the behavior of keywords from another vocabulary, or by using a keyword from another vocabulary with a restricted or expanded set of acceptable values.  Not all such vocabulary re-use will result in a new vocabulary that is compatible with the vocabulary on which it is built.  Vocabulary authors SHOULD clearly document what level of compatibility, if any, is expected.  </p>
<p id="rfc.section.4.3.2.p.4">A schema that itself describes a schema is called a meta-schema.  Meta-schemas are used to validate JSON Schemas and specify which vocabulary it is using.  <a id="CREF1" class="info">[CREF1]<span class="info">Currently, only a single meta-schema may be specified per schema, meaning that in order to use multiple vocabularies, a meta-schema must be written that encompasses all of them.  The hyper-schema meta-schema is an example of this, as it encompasses the validation vocabulary as well as the hypermedia vocabulary.  </span></a> </p>
<h1 id="rfc.section.4.3.3"><a href="#rfc.section.4.3.3">4.3.3.</a> Root Schema and Subschemas</h1>
<p id="rfc.section.4.3.3.p.1">The root schema is the schema that comprises the entire JSON document in question.  </p>
<p id="rfc.section.4.3.3.p.2">Some keywords take schemas themselves, allowing JSON Schemas to be nested: </p>
<pre>

{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

                        </pre>
<p id="rfc.section.4.3.3.p.3">In this example document, the schema titled "array item" is a subschema, and the schema titled "root" is the root schema.  </p>
<p id="rfc.section.4.3.3.p.4">As with the root schema, a subschema is either an object or a boolean.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#fragments" id="fragments">Fragment Identifiers</a></h1>
<p id="rfc.section.5.p.1">In accordance with section 3.1 of <a href="#RFC6839">[RFC6839]</a>, the syntax and semantics of fragment identifiers specified for any +json media type SHOULD be as specified for "application/json".  (At publication of this document, there is no fragment identification syntax defined for "application/json".) </p>
<p id="rfc.section.5.p.2">Additionally, the "application/schema+json" media type supports two fragment identifier structures: plain names and JSON Pointers.  The "application/schema-instance+json" media type supports one fragment identifier structure: JSON Pointers.  </p>
<p id="rfc.section.5.p.3">The use of JSON Pointers as URI fragment identifiers is described in <a href="#RFC6901">RFC 6901</a> <cite title="NONE">[RFC6901]</cite>.  For "application/schema+json", which supports two fragment identifier syntaxes, fragment identifiers matching the JSON Pointer syntax, including the empty string, MUST be interpreted as JSON Pointer fragment identifiers.  </p>
<p id="rfc.section.5.p.4">Per the W3C's <a href="#W3C.WD-fragid-best-practices-20121025">best practices for fragment identifiers</a> <cite title="NONE">[W3C.WD-fragid-best-practices-20121025]</cite>, plain name fragment identifiers in "application/schema+json" are reserved for referencing locally named schemas.  All fragment identifiers that do not match the JSON Pointer syntax MUST be interpreted as plain name fragment identifiers.  </p>
<p id="rfc.section.5.p.5">Defining and referencing a plain name fragment identifier within an "application/schema+json" document are specified in the <a href="#id-keyword">"$id" keyword</a> <cite title="NONE">[id-keyword]</cite> section.  </p>
<p/>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> General Considerations</h1>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> Range of JSON Values</h1>
<p id="rfc.section.6.1.p.1">An instance may be any valid JSON value as defined by <a href="#RFC7159">JSON</a> <cite title="NONE">[RFC7159]</cite>.  JSON Schema imposes no restrictions on type: JSON Schema can describe any JSON value, including, for example, null.  </p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#language" id="language">Programming Language Independence</a></h1>
<p id="rfc.section.6.2.p.1">JSON Schema is programming language agnostic, and supports the full range of values described in the data model.  Be aware, however, that some languages and JSON parsers may not be able to represent in memory the full range of values describable by JSON.  </p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#integers" id="integers">Mathematical Integers</a></h1>
<p id="rfc.section.6.3.p.1">Some programming languages and parsers use different internal representations for floating point numbers than they do for integers.  </p>
<p id="rfc.section.6.3.p.2">For consistency, integer JSON numbers SHOULD NOT be encoded with a fractional part.  </p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> Extending JSON Schema</h1>
<p id="rfc.section.6.4.p.1">Implementations MAY define additional keywords to JSON Schema. Save for explicit agreement, schema authors SHALL NOT expect these additional keywords to be supported by peer implementations. Implementations SHOULD ignore keywords they do not support.  </p>
<p id="rfc.section.6.4.p.2">Authors of extensions to JSON Schema are encouraged to write their own meta-schemas, which extend the existing meta-schemas using "allOf".  This extended meta-schema SHOULD be referenced using the "$schema" keyword, to allow tools to follow the correct behaviour.  </p>
<p id="rfc.section.6.4.p.3">Note that the recursive nature of meta-schemas requires re-defining recursive keywords in the extended meta-schema, as can be seen in the JSON Hyper-Schema meta-schema.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> The "$schema" Keyword</h1>
<p id="rfc.section.7.p.1">The "$schema" keyword is both used as a JSON Schema version identifier and the location of a resource which is itself a JSON Schema, which describes any schema written for this particular version.  </p>
<p id="rfc.section.7.p.2">The value of this keyword MUST be a <a href="#RFC3986">URI</a> <cite title="NONE">[RFC3986]</cite> (containing a scheme) and this URI MUST be normalized.  The current schema MUST be valid against the meta-schema identified by this URI.  </p>
<p id="rfc.section.7.p.3">If this URI identifies a retrievable resource, that resource SHOULD be of media type "application/schema+json".  </p>
<p id="rfc.section.7.p.4">The "$schema" keyword SHOULD be used in a root schema.  It MUST NOT appear in subschemas.  </p>
<p><a id="CREF2" class="info">[CREF2]<span class="info">Using multiple "$schema" keywords in the same document would imply that the vocabulary and therefore behavior can change within a document.  This would necessitate resolving a number of implementation concerns that have not yet been clearly defined.  So, while the pattern of using "$schema" only in root schemas is likely to remain the best practice for schema authoring, implementation behavior is subject to be revised or liberalized in future drafts.  </span></a> </p>
<p id="rfc.section.7.p.6">Values for this property are defined in other documents and by other parties.  JSON Schema implementations SHOULD implement support for current and previous published drafts of JSON Schema vocabularies as deemed reasonable.  </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> Base URI and Dereferencing</h1>
<p id="rfc.section.8.p.1">To differentiate between schemas in a vast ecosystem, schemas are identified by <a href="#RFC3986">URI</a> <cite title="NONE">[RFC3986]</cite>, and can embed references to other schemas by specifying their URI.  </p>
<h1 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> Initial Base URI</h1>
<p><a href="#RFC3986">RFC3986 Section 5.1</a> <cite title="NONE">[RFC3986]</cite> defines how to determine the default base URI of a document.  </p>
<p id="rfc.section.8.1.p.2">Informatively, the initial base URI of a schema is the URI at which it was found, or a suitable substitute URI if none is known.  </p>
<h1 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#id-keyword" id="id-keyword">The "$id" Keyword</a></h1>
<p id="rfc.section.8.2.p.1">The "$id" keyword defines a URI for the schema, and the base URI that other URI references within the schema are resolved against.  A subschema's "$id" is resolved against the base URI of its parent schema.  If no parent sets an explicit base with "$id", the base URI is that of the entire document, as determined per <a href="#RFC3986">RFC 3986 section 5</a> <cite title="NONE">[RFC3986]</cite>.  </p>
<p id="rfc.section.8.2.p.2">If present, the value for this keyword MUST be a string, and MUST represent a valid <a href="#RFC3986">URI-reference</a> <cite title="NONE">[RFC3986]</cite>.  This value SHOULD be normalized, and SHOULD NOT be an empty fragment &lt;#&gt; or an empty string &lt;&gt;.  </p>
<h1 id="rfc.section.8.2.1"><a href="#rfc.section.8.2.1">8.2.1.</a> Identifying the root schema</h1>
<p id="rfc.section.8.2.1.p.1">The root schema of a JSON Schema document SHOULD contain an "$id" keyword with an <a href="#RFC3986">absolute-URI</a> <cite title="NONE">[RFC3986]</cite> (containing a scheme, but no fragment), or this absolute URI but with an empty fragment.  </p>
<h1 id="rfc.section.8.2.2"><a href="#rfc.section.8.2.2">8.2.2.</a> Changing the base URI within a schema file</h1>
<p id="rfc.section.8.2.2.p.1">When an "$id" sets the base URI, the object containing that "$id" and all of its subschemas can be identified by using a JSON Pointer fragment starting from that location.  This is true even of subschemas that further change the base URI.  Therefore, a single subschema may be accessible by multiple URIs, each consisting of base URI declared in the subschema or a parent, along with a JSON Pointer fragment identifying the path from the schema object that declares the base to the subschema being identified.  Examples of this are shown in section <a href="#idExamples">8.2.4</a>.  </p>
<h1 id="rfc.section.8.2.3"><a href="#rfc.section.8.2.3">8.2.3.</a> Location-independent identifiers</h1>
<p id="rfc.section.8.2.3.p.1">Using JSON Pointer fragments requires knowledge of the structure of the schema.  When writing schema documents with the intention to provide re-usable schemas, it may be preferable to use a plain name fragment that is not tied to any particular structural location.  This allows a subschema to be relocated without requiring JSON Pointer references to be updated.  </p>
<p id="rfc.section.8.2.3.p.2">To specify such a subschema identifier, the "$id" keyword is set to a URI reference with a plain name fragment (not a JSON Pointer fragment).  This value MUST begin with the number sign that specifies a fragment ("#"), then a letter ([A-Za-z]), followed by any number of letters, digits ([0-9]), hyphens ("-"), underscores ("_"), colons (":"), or periods (".").  </p>
<p id="rfc.section.8.2.3.p.3">The effect of using a fragment in "$id" that isn't blank or doesn't follow the plain name syntax is undefined.  <a id="CREF3" class="info">[CREF3]<span class="info">How should an "$id" URI reference containing a fragment with other components be interpreted?  There are two cases:  when the other components match the current base URI and when they change the base URI.  </span></a> </p>
<h1 id="rfc.section.8.2.4"><a href="#rfc.section.8.2.4">8.2.4.</a> <a href="#idExamples" id="idExamples">Schema identification examples</a></h1>
<p>Consider the following schema, which shows "$id" being used to identify the root schema, change the base URI for subschemas, and assign plain name fragments to subschemas: </p>
<pre>

{
    "$id": "http://example.com/root.json",
    "definitions": {
        "A": { "$id": "#foo" },
        "B": {
            "$id": "other.json",
            "definitions": {
                "X": { "$id": "#bar" },
                "Y": { "$id": "t/inner.json" }
            }
        },
        "C": {
            "$id": "urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f"
        }
    }
}

                        </pre>
<p id="rfc.section.8.2.4.p.1">The schemas at the following URI-encoded <a href="#RFC6901">JSON Pointers</a> <cite title="NONE">[RFC6901]</cite> (relative to the root schema) have the following base URIs, and are identifiable by any listed URI in accordance with Section <a href="#fragments">5</a> above: </p>
<p/>

<dl>
  <dt># (document root)</dt>
  <dd style="margin-left: 8">
    <dl>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/root.json</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/root.json#</dd>
    </dl>
    <p> </p>
  </dd>
  <dt>#/definitions/A</dt>
  <dd style="margin-left: 8">
    <dl>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/root.json#foo</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/root.json#/definitions/A</dd>
    </dl>
    <p> </p>
  </dd>
  <dt>#/definitions/B</dt>
  <dd style="margin-left: 8">
    <dl>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/other.json</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/other.json#</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/root.json#/definitions/B</dd>
    </dl>
    <p> </p>
  </dd>
  <dt>#/definitions/B/definitions/X</dt>
  <dd style="margin-left: 8">
    <dl>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/other.json#bar</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/other.json#/definitions/X</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/root.json#/definitions/B/definitions/X</dd>
    </dl>
    <p> </p>
  </dd>
  <dt>#/definitions/B/definitions/Y</dt>
  <dd style="margin-left: 8">
    <dl>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/t/inner.json</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/t/inner.json#</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/other.json#/definitions/Y</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/root.json#/definitions/B/definitions/Y</dd>
    </dl>
    <p> </p>
  </dd>
  <dt>#/definitions/C</dt>
  <dd style="margin-left: 8">
    <dl>
      <dt></dt>
      <dd style="margin-left: 8">urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f</dd>
      <dt></dt>
      <dd style="margin-left: 8">urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f#</dd>
      <dt></dt>
      <dd style="margin-left: 8">http://example.com/root.json#/definitions/C</dd>
    </dl>
    <p> </p>
  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a> Schema References With "$ref"</h1>
<p id="rfc.section.8.3.p.1">The "$ref" keyword is used to reference a schema, and provides the ability to validate recursive structures through self-reference.  </p>
<p id="rfc.section.8.3.p.2">An object schema with a "$ref" property MUST be interpreted as a "$ref" reference.  The value of the "$ref" property MUST be a URI Reference.  Resolved against the current URI base, it identifies the URI of a schema to use.  All other properties in a "$ref" object MUST be ignored.  </p>
<p id="rfc.section.8.3.p.3">The URI is not a network locator, only an identifier. A schema need not be downloadable from the address if it is a network-addressable URL, and implementations SHOULD NOT assume they should perform a network operation when they encounter a network-addressable URI.  </p>
<p id="rfc.section.8.3.p.4">A schema MUST NOT be run into an infinite loop against a schema. For example, if two schemas "#alice" and "#bob" both have an "allOf" property that refers to the other, a naive validator might get stuck in an infinite recursive loop trying to validate the instance.  Schemas SHOULD NOT make use of infinite recursive nesting like this; the behavior is undefined.  </p>
<h1 id="rfc.section.8.3.1"><a href="#rfc.section.8.3.1">8.3.1.</a> Loading a referenced schema</h1>
<p id="rfc.section.8.3.1.p.1">The use of URIs to identify remote schemas does not necessarily mean anything is downloaded, but instead JSON Schema implementations SHOULD understand ahead of time which schemas they will be using, and the URIs that identify them.  </p>
<p id="rfc.section.8.3.1.p.2">When schemas are downloaded, for example by a generic user-agent that doesn't know until runtime which schemas to download, see <a href="#hypermedia">Usage for Hypermedia</a> <cite title="NONE">[hypermedia]</cite>.  </p>
<p id="rfc.section.8.3.1.p.3">Implementations SHOULD be able to associate arbitrary URIs with an arbitrary schema and/or automatically associate a schema's "$id"-given URI, depending on the trust that the validator has in the schema.  Such URIs and schemas can be supplied to an implementation prior to processing instances, or may be noted within a schema document as it is processed, producing associations as shown in section <a href="#idExamples">8.2.4</a>.  </p>
<p id="rfc.section.8.3.1.p.4">A schema MAY (and likely will) have multiple URIs, but there is no way for a URI to identify more than one schema. When multiple schemas try to identify as the same URI, validators SHOULD raise an error condition.  </p>
<h1 id="rfc.section.8.3.2"><a href="#rfc.section.8.3.2">8.3.2.</a> Dereferencing</h1>
<p id="rfc.section.8.3.2.p.1">Schemas can be identified by any URI that has been given to them, including a JSON Pointer or their URI given directly by "$id".  In all cases, dereferencing a "$ref" reference involves first resolving its value as a URI reference against the current base URI per <a href="#RFC3986">RFC 3986</a> <cite title="NONE">[RFC3986]</cite>.  </p>
<p id="rfc.section.8.3.2.p.2">If the resulting URI identifies a schema within the current document, or within another schema document that has been made available to the implementation, then that schema SHOULD be used automatically.  </p>
<p id="rfc.section.8.3.2.p.3">For example, consider this schema: </p>
<pre>

{
    "$id": "http://example.net/root.json",
    "items": {
        "type": "array",
        "items": { "$ref": "#item" }
    },
    "definitions": {
        "single": {
            "$id": "#item",
            "type": "object",
            "additionalProperties": { "$ref": "other.json" }
        }
    }
}

                        </pre>
<p id="rfc.section.8.3.2.p.4">When an implementation encounters the &lt;#/definitions/single&gt; schema, it resolves the "$id" URI reference against the current base URI to form &lt;http://example.net/root.json#item&gt;.  </p>
<p id="rfc.section.8.3.2.p.5">When an implementation then looks inside the &lt;#/items&gt; schema, it encounters the &lt;#item&gt; reference, and resolves this to &lt;http://example.net/root.json#item&gt;, which it has seen defined in this same document and can therefore use automatically.  </p>
<p id="rfc.section.8.3.2.p.6">When an implementation encounters the reference to "other.json", it resolves this to &lt;http://example.net/other.json&gt;, which is not defined in this document.  If a schema with that identifier has otherwise been supplied to the implementation, it can also be used automatically.  <a id="CREF4" class="info">[CREF4]<span class="info">What should implementations do when the referenced schema is not known? Are there circumstances in which automatic network dereferencing is allowed?  A same origin policy?  A user-configurable option?  In the case of an evolving API described by Hyper-Schema, it is expected that new schemas will be added to the system dynamically, so placing an absolute requirement of pre-loading schema documents is not feasible.  </span></a> </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> Comments With "$comment"</h1>
<p id="rfc.section.9.p.1">This keyword is reserved for comments from schema authors to readers or maintainers of the schema.  The value of this keyword MUST be a string. Implementations MUST NOT present this string to end users.  Tools for editing schemas SHOULD support displaying and editing this keyword.  The value of this keyword MAY be used in debug or error output which is intended for developers making use of schemas.  Schema vocabularies SHOULD allow "$comment" within any object containing vocabulary keywords.  Implementations MAY assume "$comment" is allowed unless the vocabulary specifically forbids it.  Vocabularies MUST NOT specify any effect of "$comment" beyond what is described in this specification.  Tools that translate other media types or programming languages to and from application/schema+json MAY choose to convert that media type or programming language's native comments to or from "$comment" values.  The behavior of such translation when both native comments and "$comment" properties are present is implementation-dependent.  Implementations SHOULD treat "$comment" identically to an unknown extension keyword.  They MAY strip "$comment" values at any point during processing.  In particular, this allows for shortening schemas when the size of deployed schemas is a concern.  Implementations MUST NOT take any other action based on the presence, absence, or contents of "$comment" properties.  </p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#hypermedia" id="hypermedia">Usage for Hypermedia</a></h1>
<p id="rfc.section.10.p.1">JSON has been adopted widely by HTTP servers for automated APIs and robots. This section describes how to enhance processing of JSON documents in a more RESTful manner when used with protocols that support media types and <a href="#RFC8288">Web linking</a> <cite title="NONE">[RFC8288]</cite>.  </p>
<h1 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> Linking to a Schema</h1>
<p id="rfc.section.10.1.p.1">It is RECOMMENDED that instances described by a schema provide a link to a downloadable JSON Schema using the link relation "describedby", as defined by <a href="#W3C.REC-ldp-20150226">Linked Data Protocol 1.0, section 8.1</a> <cite title="NONE">[W3C.REC-ldp-20150226]</cite>.  </p>
<p id="rfc.section.10.1.p.2">In HTTP, such links can be attached to any response using the <a href="#RFC8288">Link header</a> <cite title="NONE">[RFC8288]</cite>. An example of such a header would be: </p>
<pre>

Link: &lt;http://example.com/my-hyper-schema#&gt;; rel="describedby"

                    </pre>
<h1 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> <a href="#parameter" id="parameter">Identifying a Schema via a Media Type Parameter</a></h1>
<p id="rfc.section.10.2.p.1">Media types MAY allow for a "schema" media type parameter, which gives HTTP servers the ability to perform Content-Type Negotiation based on schema.  The media-type parameter MUST be a whitespace-separated list of URIs (i.e. relative references are invalid).  </p>
<p id="rfc.section.10.2.p.2">When using the media type application/schema-instance+json, the "schema" parameter MUST be supplied.  </p>
<p id="rfc.section.10.2.p.3">The schema URI is opaque and SHOULD NOT automatically be dereferenced.  If the implementation does not understand the semantics of the provided schema, the implementation can instead follow the "describedby" links, if any, which may provide information on how to handle the schema.  Since "schema" doesn't necessarily point to a network location, the "describedby" relation is used for linking to a downloadable schema.  However, for simplicity, schema authors should make these URIs point to the same resource when possible.  </p>
<p id="rfc.section.10.2.p.4">In HTTP, the media-type parameter would be sent inside the Content-Type header: </p>
<pre>

Content-Type: application/json;
          schema="http://example.com/my-hyper-schema#"

                    </pre>
<p id="rfc.section.10.2.p.5">Multiple schemas are whitespace separated: </p>
<pre>

Content-Type: application/json;
          schema="http://example.com/alice http://example.com/bob"

                    </pre>
<p><a id="CREF5" class="info">[CREF5]<span class="info">This paragraph assumes that we can register a "schema" link relation.  Should we instead specify something like "tag:json-schema.org,2017:schema" for now? </span></a> HTTP can also send the "schema" in a Link, though this may impact media-type semantics and Content-Type negotiation if this replaces the media-type parameter entirely: </p>
<pre>

Link: &lt;/alice&gt;;rel="schema", &lt;/bob&gt;;rel="schema"

                    </pre>
<h1 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3.</a> Usage Over HTTP</h1>
<p id="rfc.section.10.3.p.1">When used for hypermedia systems over a network, <a href="#RFC7231">HTTP</a> <cite title="NONE">[RFC7231]</cite> is frequently the protocol of choice for distributing schemas. Misbehaving clients can pose problems for server maintainers if they pull a schema over the network more frequently than necessary, when it's instead possible to cache a schema for a long period of time.  </p>
<p id="rfc.section.10.3.p.2">HTTP servers SHOULD set long-lived caching headers on JSON Schemas.  HTTP clients SHOULD observe caching headers and not re-request documents within their freshness period.  Distributed systems SHOULD make use of a shared cache and/or caching proxy.  </p>
<pre>

User-Agent: product-name/5.4.1 so-cool-json-schema/1.0.2 curl/7.43.0

                        </pre>
<p id="rfc.section.10.3.p.3">Clients SHOULD set or prepend a User-Agent header specific to the JSON Schema implementation or software product. Since symbols are listed in decreasing order of significance, the JSON Schema library name/version should precede the more generic HTTP library name (if any). For example: </p>
<p id="rfc.section.10.3.p.4">Clients SHOULD be able to make requests with a "From" header so that server operators can contact the owner of a potentially misbehaving script.  </p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.11.p.1">Both schemas and instances are JSON values. As such, all security considerations defined in <a href="#RFC7159">RFC 7159</a> <cite title="NONE">[RFC7159]</cite> apply.  </p>
<p id="rfc.section.11.p.2">Instances and schemas are both frequently written by untrusted third parties, to be deployed on public Internet servers.  Validators should take care that the parsing and validating against schemas doesn't consume excessive system resources.  Validators MUST NOT fall into an infinite loop.  </p>
<p id="rfc.section.11.p.3">Servers MUST ensure that malicious parties can't change the functionality of existing schemas by uploading a schema with an pre-existing or very similar "$id".  </p>
<p id="rfc.section.11.p.4">Individual JSON Schema vocabularies are liable to also have their own security considerations. Consult the respective specifications for more information.  </p>
<p id="rfc.section.11.p.5">Schema authors should take care with "$comment" contents, as a malicious implementation can display them to end-users in violation of a spec, or fail to strip them if such behavior is expected.  </p>
<p id="rfc.section.11.p.6">A malicious schema author could place executable code or other dangerous material within a "$comment".  Implementations MUST NOT parse or otherwise take action based on "$comment" contents.  </p>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> IANA Considerations</h1>
<h1 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1.</a> application/schema+json</h1>
<p id="rfc.section.12.1.p.1">The proposed MIME media type for JSON Schema is defined as follows: </p>

<ul class="empty">
  <li>Type name: application</li>
  <li>Subtype name: schema+json</li>
  <li>Required parameters: N/A</li>
  <li>Encoding considerations: Encoding considerations are identical to those specified for the "application/json" media type.  See <a href="#RFC7159">JSON</a> <cite title="NONE">[RFC7159]</cite>.  </li>
  <li>Security considerations: See Section <a href="#security">11</a> above.  </li>
  <li>Interoperability considerations: See Sections <a href="#language">6.2</a> and <a href="#integers">6.3</a> above.  </li>
  <li>Fragment identifier considerations: See Section <a href="#fragments">5</a> </li>
</ul>

<p> </p>
<h1 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2.</a> application/schema-instance+json</h1>
<p id="rfc.section.12.2.p.1">The proposed MIME media type for JSON Schema Instances that require a JSON Schema-specific media type is defined as follows: </p>

<ul class="empty">
  <li>Type name: application</li>
  <li>Subtype name: schema-instance+json</li>
  <li>Required parameters: <dl><dt>schema:</dt><dd style="margin-left: 8">A non-empty list of space-separated URIs, each identifying a JSON Schema resource.  The instance SHOULD successfully validate against at least one of these schemas.  Non-validating schemas MAY be included for purposes such as allowing clients to make use of older versions of a schema as long as the runtime instance validates against that older version.  </dd></dl><p> </p></li>
  <li>Encoding considerations: Encoding considerations are identical to those specified for the "application/json" media type.  See <a href="#RFC7159">JSON</a> <cite title="NONE">[RFC7159]</cite>.  </li>
  <li>Security considerations: See Section <a href="#security">11</a> above.  </li>
  <li>Interoperability considerations: See Sections <a href="#language">6.2</a> and <a href="#integers">6.3</a> above.  </li>
  <li>Fragment identifier considerations: See Section <a href="#fragments">5</a> </li>
</ul>

<p> </p>
<h1 id="rfc.references"><a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3986">[RFC3986]</b>
      </td>
      <td class="top"><a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6839">[RFC6839]</b>
      </td>
      <td class="top"><a>Hansen, T.</a> and <a>A. Melnikov</a>, "<a href="http://tools.ietf.org/html/rfc6839">Additional Media Type Structured Syntax Suffixes</a>", RFC 6839, DOI 10.17487/RFC6839, January 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6901">[RFC6901]</b>
      </td>
      <td class="top"><a>Bryan, P.</a>, <a>Zyp, K.</a> and <a>M. Nottingham</a>, "<a href="http://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>", RFC 6901, DOI 10.17487/RFC6901, April 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7159">[RFC7159]</b>
      </td>
      <td class="top"><a>Bray, T.</a>, "<a href="http://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>", RFC 7159, DOI 10.17487/RFC7159, March 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="W3C.REC-ldp-20150226">[W3C.REC-ldp-20150226]</b>
      </td>
      <td class="top"><a>Speicher, S.</a>, <a>Arwe, J.</a> and <a>A. Malhotra</a>, "<a href="http://www.w3.org/TR/2015/REC-ldp-20150226">Linked Data Platform 1.0</a>", World Wide Web Consortium Recommendation REC-ldp-20150226, February 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC7049">[RFC7049]</b>
      </td>
      <td class="top"><a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7231">[RFC7231]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC8288">[RFC8288]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a>, "<a href="http://tools.ietf.org/html/rfc8288">Web Linking</a>", RFC 8288, DOI 10.17487/RFC8288, October 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="W3C.WD-fragid-best-practices-20121025">[W3C.WD-fragid-best-practices-20121025]</b>
      </td>
      <td class="top"><a>Tennison, J.</a>, "<a href="http://www.w3.org/TR/2012/WD-fragid-best-practices-20121025">Best Practices for Fragment Identifiers and Media Type Definitions</a>", World Wide Web Consortium LastCall WD-fragid-best-practices-20121025, October 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="json-schema-validation">[json-schema-validation]</b>
      </td>
      <td class="top"><a>Wright, A.</a>, <a title="Cloudflare, Inc.">Andrews, H.</a> and <a>G. Luff</a>, "<a href="http://tools.ietf.org/html/draft-handrews-json-schema-validation-01">JSON Schema Validation: A Vocabulary for Structural Validation of JSON</a>", Internet-Draft draft-handrews-json-schema-validation-01, November 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="json-hyper-schema">[json-hyper-schema]</b>
      </td>
      <td class="top"><a title="Cloudflare, Inc.">Andrews, H.</a> and <a>A. Wright</a>, "<a href="http://tools.ietf.org/html/draft-handrews-json-schema-hyperschema-01">JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON</a>", Internet-Draft draft-handrews-json-schema-hyperschema-01, November 2017.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> Acknowledgments</h1>
<p id="rfc.section.A.p.1">Thanks to Gary Court, Francis Galiegue, Kris Zyp, and Geraint Luff for their work on the initial drafts of JSON Schema.  </p>
<p id="rfc.section.A.p.2">Thanks to Jason Desrosiers, Daniel Perrett, Erik Wilde, Ben Hutton, Evgeny Poberezkin, Brad Bowman, Gowry Sankar, Donald Pipowitch, and Dave Finlay for their submissions and patches to the document.  </p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> ChangeLog</h1>
<p><a id="CREF6" class="info">[CREF6]<span class="info">This section to be removed before leaving Internet-Draft status.</span></a> </p>
<p/>

<dl>
  <dt>draft-handrews-json-schema-01</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>This draft is purely a clarification with no functional changes</li>
      <li>Emphasized annotations as a primary usage of JSON Schema</li>
      <li>Clarified $id by use cases</li>
      <li>Exhaustive schema identification examples</li>
      <li>Replaced "external referencing" with how and when an implementation might know of a schema from another doucment</li>
      <li>Replaced "internal referencing" with how an implementation should recognized schema identifiers during parsing</li>
      <li>Dereferencing the former "internal" or "external" references is always the same process</li>
      <li>Minor formatting improvements</li>
    </ul>
    <p> </p>
  </dd>
  <dt>draft-handrews-json-schema-00</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>Make the concept of a schema keyword vocabulary more clear</li>
      <li>Note that the concept of "integer" is from a vocabulary, not the data model</li>
      <li>Classify keywords as assertions or annotations and describe their general behavior</li>
      <li>Explain the boolean schemas in terms of generalized assertions</li>
      <li>Reserve "$comment" for non-user-visible notes about the schema</li>
      <li>Wording improvements around "$id" and fragments</li>
      <li>Note the challenges of extending meta-schemas with recursive references</li>
      <li>Add "application/schema-instance+json" media type</li>
      <li>Recommend a "schema" link relation / parameter instead of "profile"</li>
    </ul>
    <p> </p>
  </dd>
  <dt>draft-wright-json-schema-01</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>Updated intro</li>
      <li>Allowed for any schema to be a boolean</li>
      <li>"$schema" SHOULD NOT appear in subschemas, although that may change</li>
      <li>Changed "id" to "$id"; all core keywords prefixed with "$"</li>
      <li>Clarify and formalize fragments for application/schema+json</li>
      <li>Note applicability to formats such as CBOR that can be represented in the JSON data model</li>
    </ul>
    <p> </p>
  </dd>
  <dt>draft-wright-json-schema-00</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>Updated references to JSON</li>
      <li>Updated references to HTTP</li>
      <li>Updated references to JSON Pointer</li>
      <li>Behavior for "id" is now specified in terms of RFC3986</li>
      <li>Aligned vocabulary usage for URIs with RFC3986</li>
      <li>Removed reference to draft-pbryan-zyp-json-ref-03</li>
      <li>Limited use of "$ref" to wherever a schema is expected</li>
      <li>Added definition of the "JSON Schema data model"</li>
      <li>Added additional security considerations</li>
      <li>Defined use of subschema identifiers for "id"</li>
      <li>Rewrote section on usage with HTTP</li>
      <li>Rewrote section on usage with rel="describedBy" and rel="profile"</li>
      <li>Fixed numerous invalid examples</li>
    </ul>
    <p> </p>
  </dd>
  <dt>draft-zyp-json-schema-04</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>Salvaged from draft v3.</li>
      <li>Split validation keywords into separate document.</li>
      <li>Split hypermedia keywords into separate document.</li>
      <li>Initial post-split draft.</li>
      <li>Mandate the use of JSON Reference, JSON Pointer.</li>
      <li>Define the role of "id". Define URI resolution scope.</li>
      <li>Add interoperability considerations.</li>
    </ul>
    <p> </p>
  </dd>
  <dt>draft-zyp-json-schema-00</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>Initial draft.</li>
    </ul>
    <p> </p>
  </dd>
</dl>

<p> </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Austin Wright</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Wright</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:aaa@bzfx.net">aaa@bzfx.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Henry Andrews</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Andrews</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region">CA</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:henry@cloudflare.com">henry@cloudflare.com</a></span>

  </address>
</div>

</body>
</html>
