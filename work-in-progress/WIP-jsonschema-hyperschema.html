<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>FOR PRE-PUBLICATION REVIEW ONLY: JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Notational Conventions"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Overview"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Terminology"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Functionality"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Meta-schemas and output schema"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Schema keywords"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 base"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 links"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Link Description Object"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Link context"/>
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 anchor"/>
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 anchorPointer"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Link relation type"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 rel"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 &quot;self&quot; links"/>
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 &quot;collection&quot; and &quot;item&quot; links"/>
<link href="#rfc.section.6.2.4" rel="Chapter" title="6.2.4 Using extension relation types"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Link target"/>
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 href"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Adjusting URI Template resolution"/>
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 templatePointers"/>
<link href="#rfc.section.6.4.2" rel="Chapter" title="6.4.2 templateRequired"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Link target attributes"/>
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 title"/>
<link href="#rfc.section.6.5.2" rel="Chapter" title="6.5.2 description"/>
<link href="#rfc.section.6.5.3" rel="Chapter" title="6.5.3 targetMediaType"/>
<link href="#rfc.section.6.5.4" rel="Chapter" title="6.5.4 targetSchema"/>
<link href="#rfc.section.6.5.5" rel="Chapter" title="6.5.5 targetHints"/>
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Link input"/>
<link href="#rfc.section.6.6.1" rel="Chapter" title="6.6.1 hrefSchema"/>
<link href="#rfc.section.6.6.2" rel="Chapter" title="6.6.2 headerSchema"/>
<link href="#rfc.section.6.6.3" rel="Chapter" title="6.6.3 Manipulating the target resource representation"/>
<link href="#rfc.section.6.6.4" rel="Chapter" title="6.6.4 Submitting data for processing"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Implementation requirements"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Link discovery and look-up"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 URI Templating"/>
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Populating template data from the instance"/>
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Accepting input for template data"/>
<link href="#rfc.section.7.2.3" rel="Chapter" title="7.2.3 Encoding data as strings"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Providing access to LDO keywords"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Requests"/>
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Responses"/>
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Streaming parsers"/>
<link href="#rfc.section.8" rel="Chapter" title="8 JSON Hyper-Schema and HTTP"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 One link per target and relation type"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 &quot;targetSchema&quot; and HTTP"/>
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Optimizing HTTP discoverability with &quot;targetHints&quot;"/>
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Advertising HTTP features with &quot;headerSchema&quot;"/>
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Creating resources through collections"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Examples"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Entry point links, no templates"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Individually identified resources"/>
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Submitting a payload and accepting URI input"/>
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 &quot;anchor&quot; and &quot;base&quot; as URI Templates"/>
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Collections"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 &quot;self&quot; links"/>
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Target attributes"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="12 References"/>
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Using JSON Hyper-Schema in APIs"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Resource evolution with Hyper-Schema"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Responses and errors"/>
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Static analysis of an API's hyper-schemas"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Change Log"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Andrews, H., Ed. and A. Wright, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-TO-BE-DETERMINED-json-schema-hyperschema-NN" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-10-20" />
  <meta name="dct.abstract" content="JSON Schema is a JSON based format for describing JSON data using various vocabularies.  This document specifies a vocabulary for annotating JSON documents with hyperlinks and instructions for processing and manipulating remote JSON resources through hypermedia environments such as HTTP.  " />
  <meta name="description" content="JSON Schema is a JSON based format for describing JSON data using various vocabularies.  This document specifies a vocabulary for annotating JSON documents with hyperlinks and instructions for processing and manipulating remote JSON resources through hypermedia environments such as HTTP.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Internet Engineering Task Force</td>
  <td class="right">H. Andrews, Ed.</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Cloudflare, Inc.</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">A. Wright, Ed.</td>
</tr>
<tr>
  <td class="left">Expires: April 23, 2018</td>
  <td class="right">October 20, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">FOR PRE-PUBLICATION REVIEW ONLY: JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON <br />
  <span class="filename">draft-TO-BE-DETERMINED-json-schema-hyperschema-NN</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>JSON Schema is a JSON based format for describing JSON data using various vocabularies.  This document specifies a vocabulary for annotating JSON documents with hyperlinks and instructions for processing and manipulating remote JSON resources through hypermedia environments such as HTTP.  </p>
<h1>
  <a>Note to Readers</a>
</h1>
<p>The issues list for this draft can be found at <span>&lt;</span><a href="https://github.com/json-schema-org/json-schema-spec/issues">https://github.com/json-schema-org/json-schema-spec/issues</a><span>&gt;</span>.  </p>
<p>For additional information, see <span>&lt;</span><a href="http://json-schema.org/">http://json-schema.org/</a><span>&gt;</span>.  </p>
<p>To provide feedback, use this issue tracker, the communication methods listed on the homepage, or email the document editors.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 23, 2018.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Notational Conventions</a></li>
<li>3.   <a href="#rfc.section.3">Overview</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Terminology</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Functionality</a></li>
</ul><li>4.   <a href="#rfc.section.4">Meta-schemas and output schema</a></li>
<li>5.   <a href="#rfc.section.5">Schema keywords</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">base</a></li>
<li>5.2.   <a href="#rfc.section.5.2">links</a></li>
</ul><li>6.   <a href="#rfc.section.6">Link Description Object</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Link context</a></li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">anchor</a></li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">anchorPointer</a></li>
</ul><li>6.2.   <a href="#rfc.section.6.2">Link relation type</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">rel</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">"self" links</a></li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">"collection" and "item" links</a></li>
<li>6.2.4.   <a href="#rfc.section.6.2.4">Using extension relation types</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Link target</a></li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">href</a></li>
</ul><li>6.4.   <a href="#rfc.section.6.4">Adjusting URI Template resolution</a></li>
<ul><li>6.4.1.   <a href="#rfc.section.6.4.1">templatePointers</a></li>
<li>6.4.2.   <a href="#rfc.section.6.4.2">templateRequired</a></li>
</ul><li>6.5.   <a href="#rfc.section.6.5">Link target attributes</a></li>
<ul><li>6.5.1.   <a href="#rfc.section.6.5.1">title</a></li>
<li>6.5.2.   <a href="#rfc.section.6.5.2">description</a></li>
<li>6.5.3.   <a href="#rfc.section.6.5.3">targetMediaType</a></li>
<li>6.5.4.   <a href="#rfc.section.6.5.4">targetSchema</a></li>
<li>6.5.5.   <a href="#rfc.section.6.5.5">targetHints</a></li>
</ul><li>6.6.   <a href="#rfc.section.6.6">Link input</a></li>
<ul><li>6.6.1.   <a href="#rfc.section.6.6.1">hrefSchema</a></li>
<li>6.6.2.   <a href="#rfc.section.6.6.2">headerSchema</a></li>
<li>6.6.3.   <a href="#rfc.section.6.6.3">Manipulating the target resource representation</a></li>
<li>6.6.4.   <a href="#rfc.section.6.6.4">Submitting data for processing</a></li>
</ul></ul><li>7.   <a href="#rfc.section.7">Implementation requirements</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Link discovery and look-up</a></li>
<li>7.2.   <a href="#rfc.section.7.2">URI Templating</a></li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Populating template data from the instance</a></li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Accepting input for template data</a></li>
<li>7.2.3.   <a href="#rfc.section.7.2.3">Encoding data as strings</a></li>
</ul><li>7.3.   <a href="#rfc.section.7.3">Providing access to LDO keywords</a></li>
<li>7.4.   <a href="#rfc.section.7.4">Requests</a></li>
<li>7.5.   <a href="#rfc.section.7.5">Responses</a></li>
<li>7.6.   <a href="#rfc.section.7.6">Streaming parsers</a></li>
</ul><li>8.   <a href="#rfc.section.8">JSON Hyper-Schema and HTTP</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">One link per target and relation type</a></li>
<li>8.2.   <a href="#rfc.section.8.2">"targetSchema" and HTTP</a></li>
<li>8.3.   <a href="#rfc.section.8.3">Optimizing HTTP discoverability with "targetHints"</a></li>
<li>8.4.   <a href="#rfc.section.8.4">Advertising HTTP features with "headerSchema"</a></li>
<li>8.5.   <a href="#rfc.section.8.5">Creating resources through collections</a></li>
</ul><li>9.   <a href="#rfc.section.9">Examples</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Entry point links, no templates</a></li>
<li>9.2.   <a href="#rfc.section.9.2">Individually identified resources</a></li>
<li>9.3.   <a href="#rfc.section.9.3">Submitting a payload and accepting URI input</a></li>
<li>9.4.   <a href="#rfc.section.9.4">"anchor" and "base" as URI Templates</a></li>
<li>9.5.   <a href="#rfc.section.9.5">Collections</a></li>
</ul><li>10.   <a href="#rfc.section.10">Security Considerations</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">"self" links</a></li>
<li>10.2.   <a href="#rfc.section.10.2">Target attributes</a></li>
</ul><li>11.   <a href="#rfc.section.11">Acknowledgments</a></li>
<li>12.   <a href="#rfc.references">References</a></li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Using JSON Hyper-Schema in APIs</a></li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Resource evolution with Hyper-Schema</a></li>
<li>A.2.   <a href="#rfc.appendix.A.2">Responses and errors</a></li>
<li>A.3.   <a href="#rfc.appendix.A.3">Static analysis of an API's hyper-schemas</a></li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Change Log</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">JSON Hyper-Schema is a JSON Schema vocabulary for annotating JSON documents with hyperlinks and instructions for processing and manipulating remote JSON resources through hypermedia environments such as HTTP.  </p>
<p id="rfc.section.1.p.2">The term JSON Hyper-Schema is used to refer to a JSON Schema that uses these keywords.  The term "hyper-schema" on its own refers to a JSON Hyper-Schema within the scope of this specification.  </p>
<p id="rfc.section.1.p.3">The primary mechanism introduced for specifying links is the Link Description Object (LDO), which is a serialization of the abstract link model defined in <a href="#I-D.nottingham-rfc5988bis">RFC 5988bis, section 2</a> <cite title="NONE">[I-D.nottingham-rfc5988bis]</cite>.  <a id="CREF1" class="info">[CREF1]<span class="info">This section references the work-in-progress RFC5988bis, with the expectation that it will reach RFC before this specification does.  </span></a> </p>
<p id="rfc.section.1.p.4">This specification will use the concepts, syntax, and terminology defined by the <a href="#json-schema">JSON Schema core</a> <cite title="NONE">[json-schema]</cite> and <a href="#json-schema-validation">JSON Schema validation</a> <cite title="NONE">[json-schema-validation]</cite> specifications.  It is advised that readers have a copy of these specifications.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> Notational Conventions</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> Overview</h1>
<p id="rfc.section.3.p.1">JSON Hyper-Schema makes it possible to build hypermedia systems from JSON documents by describing how to construct hyperlinks from instance data.  </p>
<p id="rfc.section.3.p.2">The combination of a JSON instance document and a valid application/schema+json hyper-schema for that instance behaves as a single hypermedia representation.  By allowing this separation, hyper-schema-based systems can gracefully support applications that expect plain JSON, while providing full hypermedia capabilities for hyper-schema-aware applications and user agents.  </p>
<p id="rfc.section.3.p.3">Client-side user agents can detect the presence of hyper-schema by looking for the application/schema+json media type and a "$schema" value that indicates the presence of the hyper-schema vocabulary.  A user agent can then use an implementation of JSON Hyper-Schema to provide an interface to the combination of the schema and instance documents as a single logical representation of a resource, just as with any single-document hypermedia representation format.  </p>
<p id="rfc.section.3.p.4">Hyper-schemas allow representations to take up fewer bytes on the wire, and distribute the burden of link construction from the server to each client.  A user agent need not construct a link unless a client application requests that link.  JSON Hyper-Schema can also be used on the server side to generate other link serializations or representation formats at runtime, or pre-emptively follow links to facilitate server push usage.  </p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> Terminology</h1>
<p id="rfc.section.3.1.p.1">The terms "schema", "instance", and "meta-schema" are to be interpreted as defined in the <a href="#json-schema">JSON Schema core specification</a> <cite title="NONE">[json-schema]</cite>.  </p>
<p id="rfc.section.3.1.p.2">The terms "applicable" and "attached" are to be interpreted as defined in <a href="#json-schema-validation">Section 10.1 of the JSON Schema validation specification</a> <cite title="NONE">[json-schema-validation]</cite>.  </p>
<p id="rfc.section.3.1.p.3">The terms "link", "link context" (or "context"), "link target" (or "target"), and "target attributes" are to be interpreted as defined in <a href="#I-D.nottingham-rfc5988bis">Section 2 of RFC 5988bis</a> <cite title="NONE">[I-D.nottingham-rfc5988bis]</cite>.  </p>
<p id="rfc.section.3.1.p.4">The term "user agent" is to be interpreted as defined in <a href="#RFC7230">Section 2.1 of RFC 7230</a> <cite title="NONE">[RFC7230]</cite>, generalized to apply to any protocol that may be used in a hypermedia system rather than specifically being an HTTP client.  </p>
<p id="rfc.section.3.1.p.5">This specification defines the following terms: </p>

<dl>
  <dt>JSON Hyper-Schema</dt>
  <dd style="margin-left: 8">A JSON Schema using the keywords defined by this specification.  </dd>
  <dt>hyper-schema</dt>
  <dd style="margin-left: 8">Within this document, the term "hyper-schema" always refers to a JSON Hyper-Schema </dd>
  <dt>link validity</dt>
  <dd style="margin-left: 8">A valid link for an instance is one that is applicable to that instance and does not fail any requirement imposed by the keywords in the Link Description Object.  </dd>
  <dt>generic user agent</dt>
  <dd style="margin-left: 8">A user agent which is only aware of standardized link relations, media types, URI schemes, and protocols.  It may have an extensible architecture to allow adding support for standards beyond the core set of which it is aware.  </dd>
  <dt>client application</dt>
  <dd style="margin-left: 8">An application which uses a hypermedia system for a specific purpose.  Such an application may also be its own user agent, or it may be built on top of a generic user agent.  A client application is programmed with knowledge of link relations, media types, URI schemes, protocols, and data structures that are specific to the application's domain.  </dd>
  <dt>client input</dt>
  <dd style="margin-left: 8">Data provided through a user agent, and most often also through a client application.  Such data may be requested from a user interactively, or provided before interaction in forms such as command-line arguments, configuration files, or hardcoded values in source code.  </dd>
  <dt>operation</dt>
  <dd style="margin-left: 8">A specific use of a hyperlink, such as making a network request (for a URI with a scheme such as "http://" that indicates a protocol) or otherwise taking action based on a link (reading data from a "data:" URI, or constructing an email message based on a "mailto:" link).  For protocols such as HTTP that support multiple methods, each method is considered to be a separate operation on the same link.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> Functionality</h1>
<p id="rfc.section.3.2.p.1">A JSON Hyper-Schema implementation is able to take a hyper-schema, an instance, and in some cases client input, and produce a set of fully resolved valid links.  As defined by <a href="#I-D.nottingham-rfc5988bis">RFC 5988bis, section 2</a> <cite title="NONE">[I-D.nottingham-rfc5988bis]</cite>, a link consists of a context, a typed relation, a target, and optionally additional target attributes.  </p>
<p id="rfc.section.3.2.p.2">The relation type and target attributes are taken directly from each link's Link Description Object.  The context and target identifiers are constructed from some combination of URI Templates, instance data, and (in the case of the target identifier) client input.  </p>
<p id="rfc.section.3.2.p.3">The target is always fully identified by a URI.  Due to the lack of a URI fragment identifier syntax for application/json and many other media types that can be used with JSON Hyper-Schema, the context may be only partially identified by a URI.  In such cases, the remaining identification will be provided as a JSON Pointer.  </p>
<p id="rfc.section.3.2.p.4">A few IANA-registered link relation types are given specific semantics in a JSON Hyper-Schema document.  A "self" link is used to interact with the resource that the instance document represents, while "collection" and "item" links identify resources for which collection-specific semantics can be assumed.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> Meta-schemas and output schema</h1>
<p><a id="CREF2" class="info">[CREF2]<span class="info">The "draft-07-wip" is a placeholder.</span></a> </p>
<p id="rfc.section.4.p.2">The current URI for the JSON Hyper-Schema meta-schema is <a href="http://json-schema.org/draft-07-wip/hyper-schema#">http://json-schema.org/draft-07-wip/hyper-schema#</a> (draft-07 work-in-progress version).  </p>
<p id="rfc.section.4.p.3">The <a href="#ldo">link description format</a> <cite title="NONE">[ldo]</cite> can be used without JSON Schema, and use of this format can be declared by referencing the normative link description schema as the schema for the data structure that uses the links.  The URI of the normative link description schema is: <a href="http://json-schema.org/draft-07-wip/links#">http://json-schema.org/draft-07-wip/links#</a> (draft-07 work-in-progress version).  </p>
<p id="rfc.section.4.p.4">JSON Hyper-Schema implementations are free to provide output in any format.  However, a specific format is defined for use in the conformance test suite, which is also used to illustrate points in the <a href="#implementation">"Implementation Requirements"</a> <cite title="NONE">[implementation]</cite>, and to show the output generated by <a href="#examples">examples</a> <cite title="NONE">[examples]</cite>.  It is RECOMMENDED that implementations be capable of producing output in this format to facilitated testing.  The URI of the JSON Schema describing the recommended output format is <a href="http://json-schema.org/draft-7-wip/hyper-schema-output#">http://json-schema.org/draft-7-wip/hyper-schema-output#</a> (draft-07 work-in-progress version).  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> Schema keywords</h1>
<p id="rfc.section.5.p.1">Hyper-schema keywords from all schemas that are applicable to a position in an instance, as defined by <a href="#json-schema-validation">Section 10.1 of JSON Schema validation</a> <cite title="NONE">[json-schema-validation]</cite>, can be used with that instance.  </p>
<p id="rfc.section.5.p.2">When multiple subschemas are applicable to a given sub-instance, all "link" arrays MUST be combined, in any order, into a single set.  Each object in the resulting set MUST retain its own list of applicable "base" values, in resolution order, from the same schema and any parent schemas.  </p>
<p id="rfc.section.5.p.3">As with all JSON Schema keywords, all keywords described in this section are optional. The minimal valid JSON Hyper-schema is the blank object.  </p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#base" id="base">base</a></h1>
<p id="rfc.section.5.1.p.1">If present, this keyword MUST be first <a href="#uriTemplating">resolved as a URI Template</a> <cite title="NONE">[uriTemplating]</cite>, and then MUST be resolved as a URI Reference against the current URI base of the instance.  The result MUST be set as the new URI base for the instance while processing the sub-schema containing "base" and all sub-schemas within it.  </p>
<p id="rfc.section.5.1.p.2">The process for resolving the "base" template can be different when being resolved for use with "anchor" than when being resolved for use with "href", which is explained in detail in the URI Templating section.  </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> links</h1>
<p id="rfc.section.5.2.p.1">The "links" property of schemas is used to associate Link Description Objects with instances.  The value of this property MUST be an array, and the items in the array must be Link Description Objects, as defined below.  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#ldo" id="ldo">Link Description Object</a></h1>
<p><a id="CREF3" class="info">[CREF3]<span class="info">This section references the work-in-progress RFC5988bis, with the expectation that it will reach RFC before this specification does.  </span></a> A Link Description Object (LDO) is a serialization of the abstract link model defined in <a href="#I-D.nottingham-rfc5988bis">RFC 5988bis, section 2</a> <cite title="NONE">[I-D.nottingham-rfc5988bis]</cite>.  As described in that document, a link consists of a context, a relation type, a target, and optionally target attributes.  JSON Hyper-Schema's LDO provides all of these, along with additional features using JSON Schema to describe input for use with the links in various ways.  </p>
<p id="rfc.section.6.p.2">Due to the use of URI Templates to identify link contexts and targets, as well as optional further use of client input when identifying targets, an LDO is a link template that may resolve to multiple links when used with a JSON instance document.  </p>
<p id="rfc.section.6.p.3">A specific use of an LDO, typically involving a request and response across a protocol, is referred to as an operation.  For many protocols, multiple operations are possible on any given link.  The protocol is indicated by the target's URI scheme.  Note that not all URI schemes indicate a protocol that can be used for communications, and even resources with URI schemes that do indicate such protocols need not be available over that protocol.  </p>
<p id="rfc.section.6.p.4">A Link Description Object MUST be an object, and the <a href="#href">"href"</a> <cite title="NONE">[href]</cite> and <a href="#rel">"rel"</a> <cite title="NONE">[rel]</cite> properties MUST be present.  Each keyword is covered briefly in this section, with additional usage explanation and comprehensive examples given later in the document.  </p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#context" id="context">Link context</a></h1>
<p id="rfc.section.6.1.p.1">In JSON Hyper-Schema, the link's context resource is, by default, the sub-instance to which it is attached (as defined by <a href="#json-schema-validation">Section 10.1 of the JSON Schema validation specification</a> <cite title="NONE">[json-schema-validation]</cite>).  This is often not the entire instance document.  This default context can be changed using the keywords in this section.  </p>
<p id="rfc.section.6.1.p.2">Depending on the media type of the instance, it may or may not be possible to assign a URI to the exact default context resource.  In particular, application/json does not define a URI fragment resolution syntax, so properties or array elements within a plain JSON document cannot be fully identified by a URI.  When it is not possible to produce a complete URI, the position of the context SHOULD be conveyed by a the URI of the instance document, together with a separate plain-string JSON Pointer.  </p>
<p id="rfc.section.6.1.p.3">Implementations MUST be able to construct the link context's URI, and (if necessary for full identification), a JSON Pointer in string representation form as per <a href="#RFC6901">RFC 6901, section 5</a> <cite title="NONE">[RFC6901]</cite> in place of a URI fragment.  The process for constructing a URI based on a URI template is given in the <a href="#uriTemplating">URI Templating</a> <cite title="NONE">[uriTemplating]</cite> section.  </p>
<h1 id="rfc.section.6.1.1"><a href="#rfc.section.6.1.1">6.1.1.</a> <a href="#anchor" id="anchor">anchor</a></h1>
<p id="rfc.section.6.1.1.p.1">This property sets the context URI of the link.  The value of the property is a <a href="#RFC6570">URI Template</a> <cite title="NONE">[RFC6570]</cite>, and the resulting <a href="#RFC3986">URI-reference</a> <cite title="NONE">[RFC3986]</cite> MUST be resolved against the base URI of the instance.  </p>
<p id="rfc.section.6.1.1.p.2">The URI is computed from the provided URI template using the same process described for the <a href="#href">"href"</a> <cite title="NONE">[href]</cite> property, with the exception that <a href="#hrefSchema">"hrefSchema"</a> <cite title="NONE">[hrefSchema]</cite> MUST NOT be applied.  Unlike target URIs, context URIs do not accept user input.  </p>
<h1 id="rfc.section.6.1.2"><a href="#rfc.section.6.1.2">6.1.2.</a> <a href="#anchorPointer" id="anchorPointer">anchorPointer</a></h1>
<p id="rfc.section.6.1.2.p.1">This property changes the point within the instance that is considered to be the context resource of the link.  The value of the property MUST be a valid JSON Pointer in JSON String representation form, or a valid <a href="#I-D.luff-relative-json-pointer">Relative JSON Pointer</a> <cite title="NONE">[I-D.luff-relative-json-pointer]</cite> which is evaluated relative to the default context.  </p>
<p id="rfc.section.6.1.2.p.2">While an alternate context with a known URI is best set with the <a href="#anchor">"anchor"</a> <cite title="NONE">[anchor]</cite> keyword, the lack of a fragment identifier syntax for application/json means that it is usually not possible to change the context within a JSON instance using a URI.  </p>
<p id="rfc.section.6.1.2.p.3">Even in "+json" media types that define JSON Pointer as a fragment identifier syntax, if the default context is nested within an array, it is not possible to obtain the index of the default context's position in that array in order to construct a pointer to another property in that same nested JSON object.  This will be demonstrated in the examples.  </p>
<p id="rfc.section.6.1.2.p.4">The result of processing this keyword SHOULD be a URI fragment if the media type of the instance allows for such a fragment.  Otherwise it MUST be a string-encoded JSON Pointer.  </p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#relationType" id="relationType">Link relation type</a></h1>
<p id="rfc.section.6.2.p.1">The link's relation type identifies its semantics.  It is the primary means of conveying how an application can interact with a resource.  </p>
<p id="rfc.section.6.2.p.2">Relationship definitions are not normally media type dependent, and users are encouraged to utilize the most suitable existing accepted relation definitions.  </p>
<h1 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#rel" id="rel">rel</a></h1>
<p id="rfc.section.6.2.1.p.1">The value of this property MUST be a string, and MUST be a single Link Relation Type as defined in RFC 5988bis, Section 2.1.  </p>
<p id="rfc.section.6.2.1.p.2">This property is required.  </p>
<h1 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#self" id="self">"self" links</a></h1>
<p id="rfc.section.6.2.2.p.1">A hyper-schema implementation MUST recognize that a link with relation type "self" that is applicable to the entire instance document describes how a user agent can interact with the resource represented by that instance document.  A "self" link MUST be resolvable from the instance, and therefore "hrefSchema" MUST NOT be present.  </p>
<p id="rfc.section.6.2.2.p.2">Hyper-schema authors SHOULD use "templateRequired" to ensure that the "self" link has all instance data that is needed for use.  </p>
<h1 id="rfc.section.6.2.3"><a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#collectionAndItem" id="collectionAndItem">"collection" and "item" links</a></h1>
<p><a href="#RFC6573">RFC 6573</a> <cite title="NONE">[RFC6573]</cite> defines and registers the "item" and "collection" link relation types.  JSON Hyper-Schema imposes additional semantics on collection resources indicated by these types.  </p>
<p id="rfc.section.6.2.3.p.2">Implementations MUST recognize the target of a "collection" link and the context of an "item" link as collections.  </p>
<p id="rfc.section.6.2.3.p.3">A well-known design pattern in hypermedia is to use a collection resource to create a member of the collection and give it a server-assigned URI.  If the protocol indicated by the URI scheme defines a specific method that is suited to creating a resource with a server-assigned URI, then a collection resource, as identified by these link relation types, MUST NOT define semantics for that method that conflict with the semantics of creating a collection member.  Collection resources MAY implement item creation via such a protocol method, and user agents MAY assume that any such operation, if it exists, has item creation semantics.  </p>
<p id="rfc.section.6.2.3.p.4">As such a method would correspond to JSON Hyper-Schema's data submission concept, the <a href="#submissionSchema">"submissionSchema"</a> <cite title="NONE">[submissionSchema]</cite> field for the link SHOULD be compatible with the schema of the representation of the collection's items, as indicated by the "item" link's target resource or the "self" link of the "collection" link's context resource.  </p>
<h1 id="rfc.section.6.2.4"><a href="#rfc.section.6.2.4">6.2.4.</a> <a href="#extensionRelationTypes" id="extensionRelationTypes">Using extension relation types</a></h1>
<p id="rfc.section.6.2.4.p.1">When no registered relation (aside from "related") applies, users are encouraged to mint their own extension relation types, as described in <a href="#RFC5988">section 4.2 of RFC 5988</a> <cite title="NONE">[RFC5988]</cite>.  The simplest approaches for choosing link relation type URIs are to either use a URI scheme that is already in use to identify the system's primary resources, or to use a human-readable, non-dereferenceable URI scheme such as <a href="#RFC4151">"tag", defined by RFC 4151</a> <cite title="NONE">[RFC4151]</cite>.  </p>
<p id="rfc.section.6.2.4.p.2">Extension relation type URIs need not be dereferenceable, even when using a scheme that allows it.  </p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#target" id="target">Link target</a></h1>
<p id="rfc.section.6.3.p.1">The target URI template is used to identify the link's target, potentially making use of instance data.  Additionally, with <a href="#hrefSchema">"hrefSchema"</a> <cite title="NONE">[hrefSchema]</cite>, this template can identify a set of possible target resources to use based on client input.  The full process of resolving the URI template, with or without client input, is covered in the <a href="#uriTemplating">URI Templating</a> <cite title="NONE">[uriTemplating]</cite> section.  </p>
<h1 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1.</a> <a href="#href" id="href">href</a></h1>
<p id="rfc.section.6.3.1.p.1">The value of the "href" link description property is a template used to determine the target URI of the related resource.  The value of the instance property MUST be resolved as a <a href="#RFC3986">URI-reference</a> <cite title="NONE">[RFC3986]</cite> against the base URI of the instance.  </p>
<p id="rfc.section.6.3.1.p.2">This property is REQUIRED.  </p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> Adjusting URI Template resolution</h1>
<p id="rfc.section.6.4.p.1">The keywords in this section are used when resolving all URI Templates involved in hyper-schema: "base", "anchor", and "href".  See the <a href="#uriTemplating">URI Templating</a> <cite title="NONE">[uriTemplating]</cite> section for the complete template resolution algorithm.  </p>
<p id="rfc.section.6.4.p.2">Note that when resolving a "base" template, the attachment point from which resolution begins is the attachment point of the "href" or "anchor" keyword being resolved which requires "base" templates to be resolved, not the attachment point of the "base" keyword itself.  </p>
<h1 id="rfc.section.6.4.1"><a href="#rfc.section.6.4.1">6.4.1.</a> <a href="#templatePointers" id="templatePointers">templatePointers</a></h1>
<p id="rfc.section.6.4.1.p.1">The value of the "templatePointers" link description property MUST be an object.  Each property value in the object MUST be a valid <a href="#RFC6901">JSON Pointer</a> <cite title="NONE">[RFC6901]</cite>, or a valid <a href="#I-D.luff-relative-json-pointer">Relative JSON Pointer</a> <cite title="NONE">[I-D.luff-relative-json-pointer]</cite> which is evaluated relative to the attachment point of the link for which the template is being resolved.  </p>
<p id="rfc.section.6.4.1.p.2">For each property name in the object that matches a variable name in the template being resolved, the value of that property adjusts the starting position of variable resolution for that variable.  Properties which do not match template variable names in the template being resolved MUST be ignored.  </p>
<h1 id="rfc.section.6.4.2"><a href="#rfc.section.6.4.2">6.4.2.</a> <a href="#templateRequired" id="templateRequired">templateRequired</a></h1>
<p id="rfc.section.6.4.2.p.1">The value of this keyword MUST be an array, and the elements MUST be unique.  Each element SHOULD match a variable in the link's URI Template, without percent-encoding.  After completing the entire URI Template resolution process, if any variable that is present in this array does not have a value, the link MUST NOT be used.  </p>
<h1 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> Link target attributes</h1>
<p id="rfc.section.6.5.p.1">All properties in this section are advisory only.  While keywords such as "title" and "description" are used primarily to present the link to users, those keywords that predict the nature of a link interaction or response MUST NOT be considered authoritative.  The runtime behavior of the target resource MUST be respected whenever it conflicts with the target attributes in the LDO.  </p>
<h1 id="rfc.section.6.5.1"><a href="#rfc.section.6.5.1">6.5.1.</a> title</h1>
<p id="rfc.section.6.5.1.p.1">This property defines a title for the link.  The value MUST be a string.  </p>
<p id="rfc.section.6.5.1.p.2">User agents MAY use this title when presenting the link to the user.  </p>
<h1 id="rfc.section.6.5.2"><a href="#rfc.section.6.5.2">6.5.2.</a> description</h1>
<p id="rfc.section.6.5.2.p.1">This property provides additional information beyond what is present in the title.  The value MUST be a string.  While a title is preferably short, a description can be used to go into more detail about the purpose and usage of the link.  </p>
<p id="rfc.section.6.5.2.p.2">User agents MAY use this description when presenting the link to the user.  </p>
<h1 id="rfc.section.6.5.3"><a href="#rfc.section.6.5.3">6.5.3.</a> targetMediaType</h1>
<p id="rfc.section.6.5.3.p.1">The value of this property represents the media type <a href="#RFC2046">RFC 2046</a> <cite title="NONE">[RFC2046]</cite>, that is expected to be returned when fetching this resource.  This property value MAY be a media range instead, using the same pattern defined in <a href="#RFC7231">RFC 7231, section 5.3.2 - HTTP "Accept" header</a> <cite title="NONE">[RFC7231]</cite>.  </p>
<p id="rfc.section.6.5.3.p.2">This property is analogous to the "type" property of other link serialization formats.  User agents MAY use this information to inform the interface they present to the user before the link is followed, but MUST NOT use this information in the interpretation of the resulting data.  Instead, a client MUST use the media type given by the response for run-time interpretation.  See the section on <a href="#security">"Security Concerns"</a> <cite title="NONE">[security]</cite> for a detailed examination of mis-use of "targetMediaType".  </p>
<p id="rfc.section.6.5.3.p.3">For protocols supporting content-negotiation, implementations MAY choose to describe possible target media types using protocol-specific information in <a href="#headerSchema">"headerSchema"</a> <cite title="NONE">[headerSchema]</cite>.  If both protocol-specific information and "targtMediaType" are present, then the value of "targetMediaType" MUST be compatible with the protocol-specific information, and SHOULD indicate the media type that will be returned in the absence of content negotiation.  </p>
<p id="rfc.section.6.5.3.p.4">When no such protocol-specific information is available, or when the implementation does not recognize the protocol involved, then the value SHOULD be taken to be "application/json".  </p>
<h1 id="rfc.section.6.5.4"><a href="#rfc.section.6.5.4">6.5.4.</a> <a href="#targetSchema" id="targetSchema">targetSchema</a></h1>
<p id="rfc.section.6.5.4.p.1">This property provides a schema that is expected to describe the link target's representation.  Depending on the protocol, the schema may or may not describe the request or response to any particular operation performed with the link. See the <a href="#HTTP">JSON Hyper-Schema and HTTP</a> <cite title="NONE">[HTTP]</cite> section for an in-depth discussion of how this keyword is used with HTTP.  </p>
<h1 id="rfc.section.6.5.5"><a href="#rfc.section.6.5.5">6.5.5.</a> <a href="#targetHints" id="targetHints">targetHints</a></h1>
<p><a id="CREF4" class="info">[CREF4]<span class="info">This section attempts to strike a balance between comprehensiveness and flexibility by deferring most of its structure to the protocol indicated by the URI scheme.  Note that a resource can be identified by a URI with a dereferenceable scheme, yet not be accessible over that protocol.  While currently very loose, this section is expected to become more well-defined based on draft feedback, and may change significantly in future drafts.  </span></a> </p>
<p id="rfc.section.6.5.5.p.2">The value of this property is advisory only.  It represents information that is expected to be discoverable through interacting with the target resource, typically in the form of protocol-specific control information or meta-data such as headers returned in response to an HTTP HEAD or OPTIONS request.  The protocol is determined by the "href" URI scheme, although note that resources are not guaranteed to be accessible over such a protocol.  </p>
<p id="rfc.section.6.5.5.p.3">The value of this property SHOULD be an object.  The keys to this object SHOULD be lower-cased forms of the control data field names.  Each value SHOULD be an array, in order to uniformly handle multi-valued fields.  Multiple values MUST be presented as an array, and not as a single string.  </p>
<p id="rfc.section.6.5.5.p.4">Protocols with control information not suitable for representation as a JSON object MAY be represented by another data type, such as an array.  </p>
<p id="rfc.section.6.5.5.p.5">Values that cannot be understood as part of the indicated protocol MUST be ignored by a JSON Hyper-Schema implementation.  Applications MAY make use of such values, but MUST NOT assume interoperability with other implementations.  </p>
<p id="rfc.section.6.5.5.p.6">Implementations MUST NOT assume that all discoverable information is accounted for in this object.  Clients MUST properly handle run-time responses that contradict this property's values.  </p>
<p id="rfc.section.6.5.5.p.7">Clients MUST NOT assume that an implementation will automatically take any action based on the value of this property.  </p>
<p id="rfc.section.6.5.5.p.8">See <a href="#HTTP">"JSON Hyper-Schema and HTTP"</a> <cite title="NONE">[HTTP]</cite> for guidance on using this keyword with HTTP and analogous protocols.  </p>
<h1 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a> <a href="#input" id="input">Link input</a></h1>
<p id="rfc.section.6.6.p.1">There are four ways to use client-supplied data with a link, and each is addressed by a separate link description object keyword.  When performing operations, clients SHOULD ignore schemas that are not relevant to their semantics.  </p>
<h1 id="rfc.section.6.6.1"><a href="#rfc.section.6.6.1">6.6.1.</a> <a href="#hrefSchema" id="hrefSchema">hrefSchema</a></h1>
<p id="rfc.section.6.6.1.p.1">The value of the "hrefSchema" link description property MUST be a valid JSON Schema.  This schema is used to validate user input or other user agent data for filling out the URI Template in <a href="#href">"href"</a> <cite title="NONE">[href]</cite>.  </p>
<p id="rfc.section.6.6.1.p.2">Omitting "hrefSchema" or setting the entire schema to "false" prevents any user agent data from being accepted.  </p>
<p id="rfc.section.6.6.1.p.3">Setting any subschema that applies to a particular variable to the JSON literal value "false" prevents any user agent data from being accepted for that single variable.  </p>
<p id="rfc.section.6.6.1.p.4">For template variables that can be resolved from the instance data, if the instance data is valid against all applicable subschemas in "hrefSchema", then it MUST be used to pre-populate the input data set for that variable.  </p>
<p id="rfc.section.6.6.1.p.5">Note that even when data is pre-populated from the instance, the validation schema for that variable in "hrefSchema" need not be identical to the validation schema(s) that apply to the instance data's location.  This allows for different validation rules for user agent data, such as supporting spelled-out months for date-time input, but using the standard date-time format for storage.  </p>
<p id="rfc.section.6.6.1.p.6">After input is accepted, potentially overriding the pre-populated instance data, the resulting data set MUST successfully validate against the value of "hrefSchema".  If it does not then the link MUST NOT be used.  If it is valid, then the process given in the "URI Templating" section continues with this updated data set.  </p>
<h1 id="rfc.section.6.6.2"><a href="#rfc.section.6.6.2">6.6.2.</a> <a href="#headerSchema" id="headerSchema">headerSchema</a></h1>
<p><a id="CREF5" class="info">[CREF5]<span class="info">As with "targetHints", this keyword is somewhat under-specified to encourage experimentation and feedback as we try to balance flexibility and clarity.  </span></a> </p>
<p id="rfc.section.6.6.2.p.2">If present, this property is a schema for protocol-specific request headers or analogous control and meta-data.  The value of this object MUST be a valid JSON Schema.  The protocol is determined by the "href" URI scheme, although note that resources are not guaranteed to be accessible over such a protocol.  The schema is advisory only; the target resource's behavior is not constrained by its presence.  </p>
<p id="rfc.section.6.6.2.p.3">The purpose of this keyword is to advertise target resource interaction features, and indicate to clients what headers and header values are likely to be useful.  Clients MAY use the schema to validate relevant headers, but MUST NOT assume that missing headers or values are forbidden from use.  While schema authors MAY set "additionalProperties" to false, this is NOT RECOMMENDED and MUST NOT prevent clients or user agents from supplying additional headers when requests are made.  </p>
<p id="rfc.section.6.6.2.p.4">The exact mapping of the JSON data model into the headers is protocol-dependent.  However, in most cases this schema SHOULD specify a type of "object", and the property names SHOULD be lower-cased forms of the control data field names.  See the <a href="#HTTP">"JSON Hyper-Schema and HTTP"</a> <cite title="NONE">[HTTP]</cite> section for detailed guidance on using this keyword with HTTP and analogous protocols.  </p>
<p id="rfc.section.6.6.2.p.5">"headerSchema" is applicable to any request method or command that the protocol supports.  When generating a request, clients SHOULD ignore schemas for headers that are not relevant to that request.  </p>
<h1 id="rfc.section.6.6.3"><a href="#rfc.section.6.6.3">6.6.3.</a> Manipulating the target resource representation</h1>
<p id="rfc.section.6.6.3.p.1">In JSON Hyper-Schema, <a href="#targetSchema">"targetSchema"</a> <cite title="NONE">[targetSchema]</cite> supplies a non-authoritative description of the target resource's representation. A client can use "targetSchema" to structure input for replacing or modifying the representation, or as the base representation for building a patch document based on a patch media type.  </p>
<p id="rfc.section.6.6.3.p.2">Alternatively, if "targetSchema" is absent or if the client prefers to only use authoritative information, it can interact with the target resource to confirm or discover its representation structure.  </p>
<p id="rfc.section.6.6.3.p.3">"targetSchema" is not intended to describe link operation responses, except when the response semantics indicate that it is a representation of the target resource.  In all cases, the schema indicated by the response itself is authoritative.  See <a href="#HTTP">"JSON Hyper-Schema and HTTP"</a> <cite title="NONE">[HTTP]</cite> for detailed examples.  </p>
<h1 id="rfc.section.6.6.4"><a href="#rfc.section.6.6.4">6.6.4.</a> Submitting data for processing</h1>
<p id="rfc.section.6.6.4.p.1">The <a href="#submissionSchema">"submissionSchema"</a> <cite title="NONE">[submissionSchema]</cite> and <a href="#submissionMediaType">"submissionMediaType"</a> <cite title="NONE">[submissionMediaType]</cite> keywords describe the domain of the processing function implemented by the target resource. Otherwise, as noted above, the submission schema and media type are ignored for operations to which they are not relevant.  </p>
<h1 id="rfc.section.6.6.4.1"><a href="#rfc.section.6.6.4.1">6.6.4.1.</a> <a href="#submissionMediaType" id="submissionMediaType">submissionMediaType</a></h1>
<p id="rfc.section.6.6.4.1.p.1">If present, this property indicates the media type format the client should use for the request payload described by <a href="#submissionSchema">"submissionSchema"</a> <cite title="NONE">[submissionSchema]</cite>.  </p>
<p id="rfc.section.6.6.4.1.p.2">Omitting this keyword has the same behavior as a value of application/json.  </p>
<p id="rfc.section.6.6.4.1.p.3">Note that "submissionMediaType" and "submissionSchema" are not restricted to HTTP URIs.  <a id="CREF6" class="info">[CREF6]<span class="info">This statement might move to wherever the example ends up.</span></a> </p>
<h1 id="rfc.section.6.6.4.2"><a href="#rfc.section.6.6.4.2">6.6.4.2.</a> <a href="#submissionSchema" id="submissionSchema">submissionSchema</a></h1>
<p id="rfc.section.6.6.4.2.p.1">This property contains a schema which defines the acceptable structure of the document to be encoded according to the "submissionMediaType" property and sent to the target resource for processing.  This can be viewed as describing the domain of the processing function implemented by the target resource.  </p>
<p id="rfc.section.6.6.4.2.p.2">This is a separate concept from the <a href="#targetSchema">"targetSchema"</a> <cite title="NONE">[targetSchema]</cite> property, which describes the target information resource (including for replacing the contents of the resource in a PUT request), unlike "submissionSchema" which describes the user-submitted request data to be evaluated by the resource. "submissionSchema" is intended for use with requests that have payloads that are not necessarily defined in terms of the target representation.  </p>
<p id="rfc.section.6.6.4.2.p.3">Omitting "submissionSchema" has the same behavior as a value of "true".  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#implementation" id="implementation">Implementation requirements</a></h1>
<p id="rfc.section.7.p.1">At a high level, a conforming implementation will meet the following requirements.  Each of these requirements is covered in more detail in the individual keyword sections and keyword group overviews.  </p>
<p id="rfc.section.7.p.2">Note that the requirements around how an implementation MUST recognize "self", "collection", and "item" links are thoroughly covered in the <a href="#relationType">link relation type</a> <cite title="NONE">[relationType]</cite> section and are not repeated here.  </p>
<p id="rfc.section.7.p.3">While it is not a mandatory format for implementations, the output format used in the test suite summarizes what needs to be computed for each link before it can be used: </p>

<dl>
  <dt>contextUri</dt>
  <dd style="margin-left: 8">The fully resolved URI (with scheme) of the context resource.  If the context is not the entire resource and there is a usable fragment identifier syntax, then the URI includes a fragment.  Note that there is no such syntax for application/json.  </dd>
  <dt>contextPointer</dt>
  <dd style="margin-left: 8">The JSON Pointer for the location within the instance of the context resource.  If the instance media type supports JSON Pointers as fragment identifiers, this pointer will be the same as the one encoded in the fragment of the "contextUri" field.  </dd>
  <dt>rel</dt>
  <dd style="margin-left: 8">The link relation type, as it appears in the LDO.  </dd>
  <dt>targetUri</dt>
  <dd style="margin-left: 8">The fully resolved URI (with a scheme) of the target resource.  If the link accepts input, this can only be produced once the input has been supplied.  </dd>
  <dt>hrefInputTemplates</dt>
  <dd style="margin-left: 8">The list of partially resolved URI references for a link that accepts input.  The first entry in the list is the partially resolved "href".  The additional entries, if any, are the partially resolved "base" values ordered from the most immediate out to the root of the schema.  Template variables that are pre-populated in the input are not resolved at this stage, as the pre-populated value can be overridden.  </dd>
  <dt>hrefPrepopulatedInput</dt>
  <dd style="margin-left: 8">The data set that the user agent should use to prepopulate any input mechanism before accepting client input.  If input is to be accepted but no fields are to be pre-populated, then this will be an empty object.  </dd>
  <dt>attachmentPointer</dt>
  <dd style="margin-left: 8">The JSON Pointer for the location within the instance to which the link is attached.  By default, "contextUri" and "attachementUri" are the same, but "contextUri" can be changed by LDO keywords, while "attachmentUri" cannot.  </dd>
</dl>

<p> Other LDO keywords that are not involved in producing the above information are included exactly as they appear when producing output for the test suite.  Those fields will not be further discussed here unless specifically relevant.  </p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> Link discovery and look-up</h1>
<p id="rfc.section.7.1.p.1">Before links can be used, they must be discovered by applying the hyper-schema to the instance and finding all applicable and valid links.  Note that in addition to collecting valid links, any <a href="#base">"base"</a> <cite title="NONE">[base]</cite> values necessary to resolve each LDO's URI Templates must also be located and associated with the LDO through whatever mechanism is most useful for the implementation's URI Template resolution process.  </p>
<p id="rfc.section.7.1.p.2">And implementation MUST support looking up links by either their attachment pointer or context pointer, either by performing the look-up or by providing the set of all links with both pointers determined so that user agents can implement the look-up themselves.  </p>
<p id="rfc.section.7.1.p.3">When performing look-ups by context pointer, links that are attached to elements of the same array MUST be returned in the same order as the array elements to which they are attached.  </p>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#uriTemplating" id="uriTemplating">URI Templating</a></h1>
<p id="rfc.section.7.2.p.1">Three hyper-schema keywords are <a href="#RFC6570">URI Templates</a> <cite title="NONE">[RFC6570]</cite>: "base", "anchor", and "href".  Each are resolved separately to URI-references, and then the anchor or href URI-reference is resolved against the base (which is itself resolved against earlier bases as needed, each of which was first resolved from a URI Template to a URI-reference).  </p>
<p id="rfc.section.7.2.p.2">All three keywords share the same algorithm for resolving variables from instance data, which makes use of the "templatePointers" and "templateRequired" keywords.  When resolving "href", both it and any "base" templates needed for resolution to an absolute URI, the algorithm is modified to optionally accept user input based on the "hrefSchema" keyword.  </p>
<p id="rfc.section.7.2.p.3">For each URI Template (T), the following pseudocode describes an algorithm for resolving T into a URI-reference (R).  For the purpose of this algorithm: </p>

<ul>
  <li>"ldo.templatePointers" is an empty object if the keyword was not present and "ldo.templateRequired" is likewise an empty array.  </li>
  <li>"attachmentPointer" is the absolute JSON Pointer for the attachment location of the LDO.  </li>
  <li>"getApplicableSchemas()" returns an iterable set of all (sub)schemas that apply to the attachment point in the instance.  </li>
</ul>

<p> </p>
<p id="rfc.section.7.2.p.4">This algorithm should be applied first to either "href" or "anchor", and then as needed to each successive "base".  The order is important, as it is not always possible to tell whether a template will resolve to a full URI or a URI-reference.  </p>
<p id="rfc.section.7.2.p.5">In English, the high-level algorithm is: </p>

<ol>
  <li>Populate template variable data from the instance</li>
  <li>If input is desired, accept input</li>
  <li>Check that all required variables have a value</li>
  <li>Encode values into strings and fill out the template</li>
</ol>

<p> </p>
<p>This is the high-level algorithm as pseudocode.  "T" comes from either "href" or "anchor" within the LDO, or from "base" in a containing schema.  Pseudocode for each step follows.  "initialTemplateKeyword" indicates which of the two started the process (since "base" is always resolved in order to finish resolving one or the other of those keywords).  </p>
<pre>

templateData = populateDataFromInstance(T, ldo, instance)

if initialTemplateKeyword == "href" and ldo.hrefSchema exists:
    inputData = acceptInput(ldo, instance, templateData)
    for varname in inputData:
        templateData[varname] = inputData[varname]

for varname in ldo.templateRequired:
    if not exists templateData[varname]
        fatal("Missing required variable(s)")

templateData = stringEncode(templateData)
R = rfc6570ResolutionAlgorithm(T, templateData)

                    </pre>
<h1 id="rfc.section.7.2.1"><a href="#rfc.section.7.2.1">7.2.1.</a> Populating template data from the instance</h1>
<p id="rfc.section.7.2.1.p.1">This step looks at various locations in the instance for variable values.  For each variable: </p>

<ol>
  <li>Use "templatePointers" to find a value if the variable appears in that keyword's value </li>
  <li>Otherwise, look for a property name matching the variable in the instance location to which the link is attached </li>
  <li>In either case, if there is a value at the location, put it in the template resolution data set </li>
</ol>

<p> </p>
<pre>

for varname in T:
    varname = rfc3986PercentDecode(varname)
    if varname in ldo.templatePointers:
        valuePointer = templatePointers[varname]
        if valuePointer is relative:
            valuePointer = resolveRelative(attachmentPointer,
                                           valuePointer)
    else
        valuePointer = attachmentPointer + "/" + varname

    value = instance.valueAt(valuePointer)
    if value is defined:
        templateData[varname] = value

                        </pre>
<h1 id="rfc.section.7.2.2"><a href="#rfc.section.7.2.2">7.2.2.</a> Accepting input for template data</h1>
<p id="rfc.section.7.2.2.p.1">This step is relatively complex, as there are several cases to support.  Some variables will forbid input and some will allow it.  Some will have initial values that need to be presented in the input interface, and some will not.  </p>
<p/>

<ol>
  <li>Deterimine which variables can accept input </li>
  <li>Pre-populate the input data set if the template resolution data set has a value </li>
  <li>Accept input (present a web form, make a callback, etc.) </li>
  <li>Validate the input data set, (not the template resolution data set) </li>
  <li>Put the input in the template resolution data set, overriding any existing values </li>
</ol>

<p> </p>
<p>"InputForm" represents whatever sort of input mechanism is appropriate.  This may be a literal web form, or may be a more programmatic construct such as a callback function accepting specific fields and data types, with the given initial values, if any.  </p>
<pre>

form = new InputForm()
for varname in T:
    useField = true
    useInitialData = true
    for schema in getApplicableSchemas(ldo.hrefSchema,
                                       "/" + varname):
        if schema is false:
            useField = false
            break

        if varname in templateData and
           not isValid(templateData[varname], schema)):
            useInitialData = false
            break

    if useField:
        if useInitialData:
            form.addInputFieldFor(varname, ldo.hrefSchema,
                                  templateData[varname])
        else:
            form.addInputFieldFor(varname, ldo.hrefSchema)

inputData = form.acceptInput()

if not isValid(inputData, hrefSchema):
    fatal("Input invalid, link is not usable")

return inputData:

                        </pre>
<h1 id="rfc.section.7.2.3"><a href="#rfc.section.7.2.3">7.2.3.</a> Encoding data as strings</h1>
<p id="rfc.section.7.2.3.p.1">This section is straightforward, converting literals to their names as strings, and converting numbers to strings in the most obvious manner, and percent-encoding as needed for use in the URI.  </p>
<pre>

for varname in templateData:
    value = templateData[varname]
    if value is true:
        templateData[varname] = "true"
    else if value is false:
        temlateData[varname] = "false"
    else if value is null:
        templateData[varname] = "null"
    else if value is a number:
        templateData[varname] =
            bestEffortOriginalJsonString(value)
    else:
        templateData[varname] = rfc3986PercentEncode(value)

                        </pre>
<p>In some software environments the original JSON representation of a number will not be available (there is no way to tell the difference between 1.0 and 1), so any reasonable representation should be used.  Schema and API authors should bear this in mind, and use other types (such as string or boolean) if the exact representation is important.  If the number was provide as input in the form of a string, the string used as input SHOULD be used.  </p>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> Providing access to LDO keywords</h1>
<p id="rfc.section.7.3.p.1">For a given link, an implementation MUST make the values of all target attribute keywords directly available to the user agent.  Implementations MAY provide additional interfaces for using this information, as discussed in each keyword's section.  </p>
<p id="rfc.section.7.3.p.2">For a given link, an implementation MUST make the value of each input schema keyword directly available to the user agent.  </p>
<p id="rfc.section.7.3.p.3">To encourage encapsulation of the URI Template resolution process, implementations MAY omit the LDO keywords that are used only to construct URIs.  However, implementations MUST provide access to the link relation type.  </p>
<p id="rfc.section.7.3.p.4">Unrecognized keywords SHOULD be made available to the user agent, and MUST otherwise be ignored.  </p>
<h1 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> Requests</h1>
<p id="rfc.section.7.4.p.1">A hyper-schema implementation SHOULD provide access to all information needed to construct any valid request to the target resource.  </p>
<p id="rfc.section.7.4.p.2">The LDO can express all information needed to perform any operation on a link.  This section explains what hyper-schema fields a user agent should examine to build requests from any combination of instance data and client input.  A hyper-schema implementation is not itself expected to construct and send requests.  </p>
<p id="rfc.section.7.4.p.3">Target URI construction rules, including "hrefSchema" for accepting input, are identical for all possible requests.  </p>
<p id="rfc.section.7.4.p.4">Requests that do not carry a body payload do not require additional keyword support.  </p>
<p id="rfc.section.7.4.p.5">Requests that take a target representation as a payload SHOULD use the "targetSchema" and "targetMediaType" keywords for input description and payload validation.  If a protocol allows an operation taking a payload that is based on the representation as modified by a media type (such as a patch media type), then such a media type SHOULD be indicated through "targetHints" in a protocol-specific manner.  </p>
<p id="rfc.section.7.4.p.6">Requests that take a payload that is not derived from the target resource's representation SHOULD use the "submissionSchema" and "submissionMediaType" keywords for input description and payload validation.  Protocols used in hypermedia generally only support one such non-representation operation per link.  </p>
<p id="rfc.section.7.4.p.7">RPC systems that pipe many application operations with arbitrarily different request structures through a single hypermedia protocol operation are outside of the scope of a hypermedia format such as JSON Hyper-Schema.  </p>
<h1 id="rfc.section.7.5"><a href="#rfc.section.7.5">7.5.</a> Responses</h1>
<p id="rfc.section.7.5.p.1">As a hypermedia format, JSON Hyper-Schema is concerned with describing a resource, including describing its links in sufficient detail to make all valid requests.  It is not concerned with directly describing all possible responses for those requests.  </p>
<p id="rfc.section.7.5.p.2">As in any hypermedia system, responses are expected to be self-describing.  In the context of hyper-schema, this means that each response MUST link its own hyper-schema(s).  While responses that consist of a representation of the target resource are expected to be valid against "targetSchema" and "targetMediaType", those keywords are advisory only and MUST be ignored if contradicted by the response itself.  </p>
<p id="rfc.section.7.5.p.3">Other responses, including error responses, complex redirections, and processing status representations SHOULD also link to their own schemas and use appropriate media types (e.g. <a href="#RFC7807">"application/problem+json"</a> <cite title="NONE">[RFC7807]</cite> for errors).  Certain errors might not link a schema due to being generated by an intermediary that is not aware of hyper-schema, rather than by the origin.  </p>
<p id="rfc.section.7.5.p.4">User agents are expected to understand protocol status codes and response media types well enough to handle common situations, and provide enough information to client applications to handle domain-specific responses.  </p>
<p id="rfc.section.7.5.p.5">Statically mapping all possible responses and their schemas at design time is outside of the scope of JSON Hyper-Schema, but may be within the scope of other JSON Schema vocabularies which build on hyper-schema (see <a href="#staticAnalysis">Appendix A.3</a>).  </p>
<h1 id="rfc.section.7.6"><a href="#rfc.section.7.6">7.6.</a> <a href="#streaming" id="streaming">Streaming parsers</a></h1>
<p id="rfc.section.7.6.p.1">The requirements around discovering links based on their context, or using the context of links to identify collections, present unique challenges when used with streaming parsers.  It is not possible to authoritatively fulfill these requirements without processing the entire schema and instance documents.  </p>
<p id="rfc.section.7.6.p.2">Such implementations MAY choose to return non-authoritative answers based on data processed to date.  When offering this approach, implementations MUST be clear on the nature of the response, and MUST offer an option to block and wait until all data is processed and an authoritative answer can be returned.  </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#HTTP" id="HTTP">JSON Hyper-Schema and HTTP</a></h1>
<p id="rfc.section.8.p.1">While JSON Hyper-Schema is a hypermedia format and therefore protocol-independent, it is expected that its most common use will be in HTTP systems, or systems using protocols such as CoAP that are explicitly analogous to HTTP.  </p>
<p id="rfc.section.8.p.2">This section provides guidance on how to define links for use with each common HTTP method, and how collection resources impose additional constraints on the use of HTTP POST.  Additionally, guidance is provided on hinting at HTTP response header values and describing possible HTTP request headers that are relevant to the given resource.  </p>
<h1 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> One link per target and relation type</h1>
<p id="rfc.section.8.1.p.1">Link Description Objects do not directly indicate what operations, such as HTTP methods, are supported by the target resource.  Instead, operations should be inferred primarily from link <a href="#rel">relation types</a> <cite title="NONE">[rel]</cite> and URI schemes.  </p>
<p id="rfc.section.8.1.p.2">This means that for each target resource and link relation type pair, schema authors SHOULD only define a single LDO.  While it is possible to use "allow" with "targetHints" to repeat a relation type and target pair with different HTTP methods marked as allowed, this is NOT RECOMMENDED and may not be well-supported by conforming implementations.  </p>
<p id="rfc.section.8.1.p.3">All information necessary to use each HTTP method can be conveyed in a single LDO as explained in this section.  The "allow" field in "targetHints" is intended simply to hint at which operations are supported, not to separately define each operation.  </p>
<p id="rfc.section.8.1.p.4">Note, however, that a resource may always decline an operation at runtime, for instance due to authorization failure, or due to other application state that controls the operation's availability.  </p>
<h1 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#targetHTTP" id="targetHTTP">"targetSchema" and HTTP</a></h1>
<p id="rfc.section.8.2.p.1">The relationship between a resource's representation and HTTP requests and responses is determined by <a href="#RFC7231">RFC 7231, section 4.3.1 - "GET", section 4.3.4 "PUT", and section 3.1.4.2, "Content-Location"</a> <cite title="NONE">[RFC7231]</cite>.  In particular, "targetSchema" suggests what a client can expect for the response to an HTTP GET or any response for which the "Content-Location" header is equal to the request URI, and what a client should send if it replaces the resource in an HTTP PUT request.  </p>
<p id="rfc.section.8.2.p.2">The media type of the representation is given by the "targetMediaType" field.  Alternatively, possible available media types MAY be advertised for HTTP-accessible resources using the "accept" field in "headerSchema", corresponding to the HTTP "Accept" header.  </p>
<p id="rfc.section.8.2.p.3">Per <a href="#RFC5789">RFC 5789</a> <cite title="NONE">[RFC5789]</cite>, the request structure for an HTTP PATCH is determined by the combination of "targetSchema" and the request media type, which is conveyed by the "Accept-Patch" header.  Media types that are suitable for PATCH-ing define a syntax for expressing changes to a document, which can be applied to the representation described by "targetSchema" to determine the set of syntactically valid request payloads.  </p>
<p id="rfc.section.8.2.p.4">HTTP POST request payloads are described by the "submissionSchema" and "submissionMediaType" fields.  Additionally, the "Accept-Post" header can be used to specify the necessary media type, and MAY be advertised via the "targetHints" field.  <a id="CREF7" class="info">[CREF7]<span class="info">What happens if both are used?  Also, "submissionSchema" is a MUST to support, while "targetHints" are at most a SHOULD.  But forbidding the use of "Accept-Post" in "targetHints" seems incorrect.  </span></a> </p>
<h1 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a> Optimizing HTTP discoverability with "targetHints"</h1>
<p><a id="CREF8" class="info">[CREF8]<span class="info">It would be good to also include a section with CoAP examples.</span></a> </p>
<p id="rfc.section.8.3.p.2">JSON serializations of HTTP response header information SHOULD follow the guidelines established by the work in progress <a href="#I-D.reschke-http-jfv">"A JSON Encoding for HTTP Header Field Values"</a> <cite title="NONE">[I-D.reschke-http-jfv]</cite>.  Approaches shown in that document's examples SHOULD be applied to other similarly structured headers wherever possible.  </p>
<p id="rfc.section.8.3.p.3">No distinction is made between headers that may appear in responses to different methods, such as HEAD vs OPTIONS.  </p>
<p id="rfc.section.8.3.p.4">It is RECOMMENDED that schema authors provide hints for the values of the following types of HTTP headers whenever applicable: </p>

<ul>
  <li>Method allowance</li>
  <li>Method-specific request media types</li>
  <li>Authentication challenges</li>
</ul>

<p> </p>
<p id="rfc.section.8.3.p.5">In general, headers that are likely to have different values at different times SHOULD NOT be included in "targetHints".  </p>
<h1 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a> Advertising HTTP features with "headerSchema"</h1>
<p id="rfc.section.8.4.p.1">Schemas SHOULD be written to describe JSON serializations that follow guidelines established by the work in progress <a href="#I-D.reschke-http-jfv">"A JSON Encoding for HTTP Header Field Values"</a> <cite title="NONE">[I-D.reschke-http-jfv]</cite> Approaches shown in that document's examples SHOULD be applied to other similarly structured headers wherever possible.  </p>
<p id="rfc.section.8.4.p.2">It is RECOMMENDED that schema authors describe the available usage of the following types of HTTP headers whenever applicable: </p>

<ul>
  <li>Content negotiation</li>
  <li>Authentication and authorization</li>
  <li>Range requests</li>
  <li>The "Prefer" header</li>
</ul>

<p> </p>
<p id="rfc.section.8.4.p.3">Headers such as cache control and conditional request headers are generally implemented by intermediaries rather than the resource, and are therefore not generally useful to describe.  While the resource must supply the information needed to use conditional requests, the runtime handling of such headers and related responses is not resource-specific.  </p>
<h1 id="rfc.section.8.5"><a href="#rfc.section.8.5">8.5.</a> Creating resources through collections</h1>
<p id="rfc.section.8.5.p.1">When using HTTP, or a protocol such as CoAP that is explicitly analogous to HTTP, this is done by POST-ing a representation of the individual resource to be created to the collection resource.  The process for recognizing collection and item resources is described in <a href="#collectionAndItem">Section 6.2.3</a>.  </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#examples" id="examples">Examples</a></h1>
<p id="rfc.section.9.p.1">This section shows how the keywords that construct URIs and JSON Pointers are used.  The results are shown in the format used by the test suite.  <a id="CREF9" class="info">[CREF9]<span class="info">Need to post that and link it, but it should be pretty self-explanatory to those of you reviewing things at this stage.  </span></a> </p>
<p id="rfc.section.9.p.2">Most other keywords are either straightforward ("title" and "description"), apply validation to specific sorts of input, requests, or responses, or have protocol-specific behavior.  Examples demonstrating HTTP usage are available in <a href="#HTTP">an Appendix</a> <cite title="NONE">[HTTP]</cite>.  </p>
<h1 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> Entry point links, no templates</h1>
<p id="rfc.section.9.1.p.1">For this example, we will assume an example API with a documented entry point URI of https://example.com, which is an empty JSON object with a link to a schema.  Here, the entry point has no data of its own and exists only to provide an initial set of links: </p>
<pre>

GET https://api.example.com HTTP/1.1

200 OK
Content-Type: application/json
Link: &lt;https://schema.example.com/entry&gt; rel=describedBy
{}

                    </pre>
<p id="rfc.section.9.1.p.2">The linked hyper-schema defines the API's base URI and provides two links:  an "about" link to API documentation, and a "self" link indicating that this is a schema for the base URI.  In this case the base URI is also the entry point URI.  </p>
<pre>

{
    "$id": "https://schema.example.com/entry",
    "$schema": "http://json-schema.org/draft-07-wip/hyper-schema#",
    "base": "https://api.example.com",
    "links": [
        {
            "rel": "self",
            "href": ""
        },
        {
            "rel": "about",
            "href": "/docs"
        }
    ]
}
                    </pre>
<p id="rfc.section.9.1.p.3">These are the simplest possible links, with only a relation type and an "href" with no template variables.  They resolve as follows: </p>
<pre>
[
    {
        "contextUri": "https://api.example.com",
        "contextPointer": "",
        "rel": "self",
        "targetUri": "https://api.example.com",
        "attachmentPointer": ""
    },
    {
        "contextUri": "https://api.example.com",
        "contextPointer": "",
        "rel": "about",
        "targetUri": "https://api.example.com/docs",
        "attachmentPointer": ""
    }
]
                    </pre>
<p id="rfc.section.9.1.p.4">The attachment pointer is the root pointer (the only possiblity with an empty object for the instance).  The context URI is the default, which is the requested document.  Since application/json does not allow for fragments, the context pointer is necessary to fully describe the context.  Its default behavior is to be the same as the attachment pointer.  </p>
<h1 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> Individually identified resources</h1>
<p id="rfc.section.9.2.p.1">Let's add "things" to our system, starting with an individual thing: </p>
<pre>
{
    "$id": "https://schema.example.com/thing",
    "$schema": "http://json-schema.org/draft-07-wip/hyper-schema#",
    "base": "https://api.example.com",
    "type": "object",
    "required": ["data"],
    "properties": {
        "id": {"$ref": "#/definitions/id"},
        "data": true
    },
    "links": [
        {
            "rel": "self",
            "href": "things/{id}",
            "templateRequired": ["id"],
            "targetSchema": {"$ref": "#"}
        }
    ],
    "definitions": {
        "id": {
            "type": "integer",
            "minimum": 1,
            "readOnly": true
        }
    }
}
                    </pre>
<p id="rfc.section.9.2.p.2">Our "thing" has a server-assigned id, which is required in order to construct the "self" link.  It also has a "data" field which can be of any type.  The reason for the "definitions" section will be clear in the next example.  </p>
<p id="rfc.section.9.2.p.3">Note that "id" is not required by the validation schema, but is required by the self link.  This makes sense: a "thing" only has a URI if it has been created, and the server has assigned an id.  However, you can use this schema with an instance containing only the data field, which allows you to validate "thing" instances that you are about to create.  </p>
<p id="rfc.section.9.2.p.4">Let's add a link to our entry point schema that lets you jump directly to a particular thing if you can supply it's id as input.  To save space, only the new LDO is shown.  Unlike "self" and "about", there is no IANA-registered relationship about hypothetical things, so an extension relationship is defined using the <a href="#RFC4151">"tag:" URI scheme</a> <cite title="NONE">[RFC4151]</cite>: </p>
<pre>
{
    "rel": "tag:rel.example.com,2017:thing",
    "href": "things/{id}",
    "hrefSchema": {
        "required": ["id"],
        "properties": {
            "id": {"$ref": "thing#/definitions/id"}
        }
    },
    "targetSchema": {"$ref": "thing#"}
}
                    </pre>
<p id="rfc.section.9.2.p.5">The "href" value here is the same, but everything else is different.  Recall that the instance is an empty object, so "id" cannot be resolved from instance data.  Instead it is required as client input.  This LDO could also have used "templateRequired" but with "required" in "hrefSchema" it is not strictly necessary.  Providing "templateRequired" without marking "id" as required in "hrefSchema" would lead to errors, as client input is the only possible source for resolving this link.  </p>
<h1 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3.</a> Submitting a payload and accepting URI input</h1>
<p id="rfc.section.9.3.p.1">This example covers using the "submission" fields for non-representation input, as well as using them alongside of resolving the URI Template with input.  Unlike HTML forms, which require either constructing a URI or sending a payload, but do not allow not both at once, JSON Hyper-Schema can describe both sorts of input to for the same operation on the same link.  </p>
<p id="rfc.section.9.3.p.2">The "submissionSchema" and "submissionMediaType" fields are for describing payloads that are not representations of the target resource.  When used with "http(s)://" URIs, they generally refer to a POST request payload, as seen in the <a href="#HTTP">appendix on HTTP usage</a> <cite title="NONE">[HTTP]</cite>.  </p>
<p id="rfc.section.9.3.p.3">In this case, we use a "mailto:" URI, which, per <a href="#RFC6068">RFC 6068, Section 3"</a> <cite title="NONE">[RFC6068]</cite>, does not provide any operation for retrieving a resource.  It can only be used to construct a message for sending.  Since there is no concept of a retrievable, replaceable, or deletable target resource, "targetSchema" and "targetMediaType" are not used.  Non-representation payloads are described by "submissionSchema" and "submission MediaType".  </p>
<p id="rfc.section.9.3.p.4">Therefore, we use "submissionMediaType" to indicate a multipart/alternative payload format, providing two representations of the same data (HTML and plain text).  Since a multipart/alternative message is an ordered sequence (the last part is the most preferred alternative), we model the sequence as an array in "submissionSchema".  Since each part is itself a document with a media type, we model each item in the array as a string, using "contentMediaType" to indicate the format within the string.  </p>
<p id="rfc.section.9.3.p.5">Note that media types such as multipart/form-data, which associate a name with each part and are not ordered, should be modeled as JSON objects rather than arrays.  </p>
<p id="rfc.section.9.3.p.6">For the URI parameters, each of the three demonstrates a different way of resolving the input: </p>

<dl>
  <dt>email:</dt>
  <dd style="margin-left: 8">This variable's presence in "templateRequired" means that it must be resolved for the template to be used.  Since the "false" schema assigned to it in "hrefSchema" excludes it from the input data set, it must be resolved from the instance.  </dd>
  <dt>title:</dt>
  <dd style="margin-left: 8">The instance field matching this variable is required, and it is also allowed in the input data.  So its instance value is used to pre-populate the input data set before accepting the client's input.  The client can opt to leave the instance value in place.  Since this field is required in "hrefSchema", the client cannot delete it (although it could set it to an empty string).  </dd>
  <dt>cc:</dt>
  <dd style="margin-left: 8">The "false" schema set for this in the main schema prevents this field from having an instance value.  If it is present at all, it must come from client input.  As it is not required in "hrefSchema", it may not be used at all.  </dd>
</dl>

<p> </p>
<p>Note that some lines are wrapped to fit this document's width restrictions.  </p>
<pre>
{
    "$id": "https://schema.example.com/interesting-stuff",
    "$schema": "http://json-schema.org/draft-07-wip/hyper-schema#",
    "required": ["stuffWorthEmailingAbout", "email", "title"],
    "properties": {
        "title": {
            "type": "string"
        },
        "stuffWorthEmailingAbout": {
            "type": "string"
        },
        "email": {
            "type": "string",
            "format": "email"
        },
        "cc": false
    },
    "links": [
        {
            "rel": "author",
            "href": "mailto:{email}?subject={title}{&amp;cc}",
            "templateRequired": ["email"],
            "hrefSchema": {
                "required": ["title"],
                "properties": {
                    "title": {
                        "type": "string"
                    },
                    "cc": {
                        "type": "string",
                        "format": "email"
                    },
                    "email": false
                }
            }
            "submissionMediaType":
                    "multipart/alternative; boundary=ab2",
            "submissionSchema": {
                "type": "array",
                "items": [
                    {
                        "type": "string",
                        "contentMediaType":
                                "text/plain; charset=utf8"
                    },
                    {
                        "type": "string",
                        "contentMediaType": "text/html"
                    }
                ],
                "minItems": 2
            }
        }
    ]
}
                    </pre>
<p id="rfc.section.9.3.p.7">So, given the following instance retrieved from "https://api.example.com/stuff": </p>
<pre>
{
    "title": "The Awesome Thing",
    "stuffWorthEmailingAbout": "Lots of text here...",
    "email": "someone@exapmle.com"
}
                    </pre>
<p id="rfc.section.9.3.p.8">We can partially resolve the link as follows, before asking the client for input.  </p>
<pre>
{
    "contextUri": "https://api.example.com/stuff",
    "contextPointer": "",
    "rel": "author",
    "hrefInputTemplates": [
      "mailto:someone@example.com?subject={title}{&amp;cc}",
    ],
    "hrefPrepopulatedInput": {
        "title": "The Really Awesome Thing"
    },
    "attachmentPointer": ""
}
                    </pre>
<p id="rfc.section.9.3.p.9">Notice the "href*" keywords in place of "targetUri".  These are three possible "targetUri" values covering different sorts of input: </p>

<dl>
  <dt>No additional or changed input:</dt>
  <dd style="margin-left: 8">"mailto:someone@example.com?subject=The%20Awesome%20Thing" </dd>
  <dt>Change "title" to "your work":</dt>
  <dd style="margin-left: 8">"mailto:someone@example.com?subject=your%20work" </dd>
  <dt>Change title and add a "cc" of "other@elsewhere.org":</dt>
  <dd style="margin-left: 8">"mailto:someone@example.com?subject=your%20work&amp;cc=other@elsewhere.org" </dd>
</dl>

<p> </p>
<h1 id="rfc.section.9.4"><a href="#rfc.section.9.4">9.4.</a> "anchor" and "base" as URI Templates</h1>
<p>
  <a id="CREF10" class="info">[CREF10]<span class="info">"base" used as a template with both "anchor" and "href" templates.  </span></a>
</p>
<h1 id="rfc.section.9.5"><a href="#rfc.section.9.5">9.5.</a> Collections</h1>
<p>
  <a id="CREF11" class="info">[CREF11]<span class="info">Reciprocal collection/item relations Pagination: fixed links vs jumping to an arbitrary offset Using "anchorPointer" and "templatePointers" Discovering ordered links Multiple self links (for the collection and each item) </span></a>
</p>
<p id="rfc.section.9.5.p.2">In many systems, individual resources are grouped into collections.  Those collections also often provide a way to create individual item resources with server-assigned identifiers.  </p>
<p id="rfc.section.9.5.p.3">This schema describes a collection where each item representation is identical to the individual resource item representation, and there is enough metadata included in the collection representation to produce pagination links.  The "first" and "last" pagination links were omitted as this is already a long example.  </p>
<p id="rfc.section.9.5.p.4">Note that there is an object member called "items", which is an array and thefore uses the validation keyword "items" in its own schema.  The outer "items" is a property name, the inner one is a schema keyword.  </p>
<pre>
{
    "$id": "https://schema.example.com/thing-collection",
    "$schema": "http://json-schema.org/draft-07-wip/hyper-schema#",
    "base": "https://api.example.com",
    "type": "object",
    "required": ["items"],
    "properties": {
        "items": {
            "type": "array",
            "items": {
                "allOf": [{"$ref": "thing#"}],
                "links": [
                    {
                        "anchorPointer": "",
                        "rel": "item",
                        "href": "things/{id}",
                        "hrefRequired": ["id"],
                        "targetSchema": {"$ref": "thing#"}
                    }
                ]
            }
        },
        "meta": {
            "type": "object",
            "properties": {
                "prev": {"$ref": "#/definitions/scrolling"},
                "current": {"$ref": "#/definitions/scrolling"},
                "next": {"$ref": "#/definitions/scrolling"}
            }
        }
    },
    "links": [
        {
            "rel": "self",
            "href": "things{?offset,limit}",
            "hrefRequired": ["offset", "limit"],
            "hrefPointers": {
                "offset": "/meta/current/offset",
                "limit": "/meta/current/limit"
            },
            "targetSchema": {"$ref": "#"}
        },
        {
            "rel": "prev",
            "href": "things{?offset,limit}",
            "hrefRequired": ["offset", "limit"],
            "hrefPointers": {
                "offset": "/meta/prev/offset",
                "limit": "/meta/prev/limit"
            },
            "targetSchema": {"$ref": "#"}
        },
        {
            "rel": "next",
            "href": "things{?offset,limit}",
            "hrefRequired": ["offset", "limit"],
            "hrefPointers": {
                "offset": "/meta/next/offset",
                "limit": "/meta/next/limit"
            },
            "targetSchema": {"$ref": "#"}
        }
    ],
    "definitions": {
        "scrolling": {
            "type": "object",
            "properties": {
                "offset": {
                    "type": "integer",
                    "minimum": 0,
                    "default": 0
                },
                "limit": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 100,
                    "default": 10
                }
            }
        }
    }
}
                    </pre>
<p>Notice that the "self" link includes the pagination query that produced the exact representation, rather than being a generic link to the collection allowing selecting the page via input.  There is no link for manual page selection in the example as shown here, nor is there a "submissionSchema" for item creation, but we will consider those additions further down.  </p>
<pre>
{
    "items": [
        {"id": 12345, "data": {}},
        {"id": 67890, "data": {}}
    ],
    "meta": {
        "current": {
            "offset": 0,
            "limit": 2
        },
        "next": {
            "offset": 3,
            "limit": 2
        }
    }
}
                    </pre>
<p>Here are all of the links that apply to this instance, including those that are referenced by using the "thing" schema for the individual items.  The "self" links for the overal resource and each individual item are distinguished by different context pointers.  Note also that the "item" and "self" links for a given thing have identical target URIs but different context pointers.  </p>
<pre>
[
    {
        "contextUri": "https://api.example.com/things",
        "contextPointer": "",
        "rel": "self",
        "targetUri": "https://api.example.com/things?offset=20,limit=2",
        "attachmentPointer": ""
    },
    {
        "contextUri": "https://api.example.com/things",
        "contextPointer": "",
        "rel": "next",
        "targetUri": "https://api.example.com/things?offset=22,limit=2",
        "attachmentPointer": ""
    },
    {
        "contextUri": "https://api.example.com/things",
        "contextPointer": "",
        "rel": "item",
        "targetUri": "https://api.example.com/things/1234",
        "attachmentPointer": "/items/0"
    },
    {
        "contextUri": "https://api.example.com/things",
        "contextPointer": "",
        "rel": "item",
        "targetUri": "https://api.example.com/things/67890",
        "attachmentPointer": "/items/1"
    },
    {
        "contextUri": "https://api.example.com/things",
        "contextPointer": "/items/0",
        "rel": "self",
        "targetUri": "https://api.example.com/things/1234",
        "attachmentPointer": "/items/0"
    },
    {
        "contextUri": "https://api.example.com/things",
        "contextPointer": "/items/1",
        "rel": "self",
        "targetUri": "https://api.example.com/things/67890",
        "attachmentPointer": "/items/1"
    }
]

                    </pre>
<p>Note that there is no "prev" link in the output, as we are looking at the first page.  The lack of a "prev" field under "meta", together with the "prev" link's "hrefRequired" values, means that the link is not usable with this particular instance.  </p>
<p id="rfc.section.9.5.p.5">To fully specify our collection, we also need to add the following link to our "thing" schema.  Note that this would cause it to also appear as a link in each item in the collection representation, which is a good example of why it is best to only construct links upon request.  There is no need for having as many functionally identical "collection" links as there are items in a collection page on every collection representation.  </p>
<p>This link would be added to the top-level "links" array in the "https://schemasexample.com/thing" schema.  </p>
<pre>
{
    "rel": "collection",
    "href": "/things",
    "targetSchema": {"$ref": "thing-collection#"},
    "submissionSchema": {"$ref": "#"}
}
                    </pre>
<p>Here we see the "submissionSchema" indicating that we can create a single "thing" by submitting a representation (minus server-created fields such as "id") to the collection that is this link's target schema.  While we cannot, in general, make assumptions about the semantics of making a data submission request (in HTTP terms, a POST), <a href="#collectionAndItem">Section 6.2.3</a> tells us that we MAY make such an assumption when the link relation is "collection", and that hyper-schema authors MUST NOT use a "collection" link if the data submission operation has semantics other than item creation.  </p>
<p><a id="CREF12" class="info">[CREF12]<span class="info">I left off the scrolling parameters for this link.  Technically, the link should go to the page containing the specific "thing" that is the context of the link.  If the collection is using semantic sorting, then this is do-able (ideally setting the page boundary such that this is the first item, and allowing input on the page count / "limit" parameter).  But getting into semantic scrolling/pagination seems way too involved for this example.  </span></a> </p>
<p><a id="CREF13" class="info">[CREF13]<span class="info">Note also that POST-ing to a collection page that will not contain the created item also seems weird.  While retrieving the collection from a query parameter-less URI will still retrieve a page, that's a limit imposed by the server.  POST-ing to such a URI and disregarding the "default" values for the parameters seems correct.  This is another reason to *not* automatically write default values into the query.  </span></a> </p>
<p id="rfc.section.9.5.p.8">But what if we do not have any "thing"s yet?  We cannot get to the individual "thing" schema as there is no individual "thing" to fetch.  And the "tag:rel.example.com,2017:thing" link in the entry point resource does not indicate how to create a "thing".  The "self" link requires the "id" to already exist, but it is assigned by the server.  So we need to add another link to our entry point schema: </p>
<p>This LDO would be added to the top-level "links" array in the entry point resource's hyper-schema.  </p>
<pre>
{
    "rel": "tag:rel.example.com,2017:thing-collection",
    "href": "/things{?offset,limit}",
    "hrefSchema": {
        "$ref": "thing-collection#/definitions/scrolling"
    },
    "submissionSchema": {
        "$ref": "thing#"
    },
    "targetSchema": {
        "$ref": "thing-collection#"
    }
}
                    </pre>
<p>Now we see the scrolling parameters being accepted as input, so we can jump to any scroll window within the collection.  </p>
<p><a id="CREF14" class="info">[CREF14]<span class="info">Here we also see the "submissionSchema" to use to create a "thing", but how do we recognize it?  We can't use a "collection" link relation here, because there is no identifiable "thing" to serve as the context resource.  We could look at the submission schema, notice that it has a "collection" link and is therefore an item, and notice that its "collection" link produces the same(-ish?) URI, but that seems overly complicated and also gets into trouble with query parameters again.  </span></a> </p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p>
  <a id="CREF15" class="info">[CREF15]<span class="info">Need to reference the core and validation security considerations.</span></a>
</p>
<h1 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> "self" links</h1>
<p id="rfc.section.10.1.p.1">When link relation of "self" is used to denote a full representation of an object, the user agent SHOULD NOT consider the representation to be the authoritative representation of the resource denoted by the target URI if the target URI is not equivalent to or a sub-path of the URI used to request the resource representation which contains the target URI with the "self" link.  </p>
<h1 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> Target attributes</h1>
<p><a id="CREF16" class="info">[CREF16]<span class="info">This whole section needs more work, but I do like having security concerns around target interactions consolidated and addressed as a whole.  </span></a> </p>
<p id="rfc.section.10.2.p.2">The "targetMediaType" property in link definitions defines the expected format of the link's target.  However, this is advisory only, and MUST NOT be considered authoritative.  </p>
<p id="rfc.section.10.2.p.3">When choosing how to interpret data, the type information provided by the server (or inferred from the filename, or any other usual method) MUST be the only consideration, and the "targetMediaType" property of the link MUST NOT be used.  User agents MAY use this information to determine how they represent the link or where to display it (for example hover-text, opening in a new tab).  If user agents decide to pass the link to an external program, they SHOULD first verify that the data is of a type that would normally be passed to that external program.  </p>
<p id="rfc.section.10.2.p.4">This is to guard against re-interpretation of "safe" data, similar to the precautions for "targetSchema".  </p>
<p id="rfc.section.10.2.p.5">The "targetSchema" keyword has similar security concerns to that of "targetMediaType".  Clients MUST NOT use the value of this property to aid in the interpretation of the data received in response to following the link, as this leaves "safe" data open to re-interpretation.  </p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> Acknowledgments</h1>
<p id="rfc.section.11.p.1">Thanks to Gary Court, Francis Galiegue, Kris Zyp, and Geraint Luff for their work on the initial drafts of JSON Schema.  </p>
<p id="rfc.section.11.p.2">Thanks to Jason Desrosiers, Daniel Perrett, Erik Wilde, Ben Hutton, Evgeny Poberezkin, Brad Bowman, Gowry Sankar, Donald Pipowitch, Dave Finlay, and Denis Laxalde for their submissions and patches to the document.  </p>
<h1 id="rfc.references"><a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3986">[RFC3986]</b>
      </td>
      <td class="top"><a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6570">[RFC6570]</b>
      </td>
      <td class="top"><a>Gregorio, J.</a>, <a>Fielding, R.</a>, <a>Hadley, M.</a>, <a>Nottingham, M.</a> and <a>D. Orchard</a>, "<a href="http://tools.ietf.org/html/rfc6570">URI Template</a>", RFC 6570, DOI 10.17487/RFC6570, March 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6901">[RFC6901]</b>
      </td>
      <td class="top"><a>Bryan, P.</a>, <a>Zyp, K.</a> and <a>M. Nottingham</a>, "<a href="http://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>", RFC 6901, DOI 10.17487/RFC6901, April 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.luff-relative-json-pointer">[I-D.luff-relative-json-pointer]</b>
      </td>
      <td class="top"><a>Luff, G.</a>, "<a href="http://tools.ietf.org/html/draft-luff-relative-json-pointer-00">Relative JSON Pointers</a>", Internet-Draft draft-luff-relative-json-pointer-00, July 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.reschke-http-jfv">[I-D.reschke-http-jfv]</b>
      </td>
      <td class="top"><a>Reschke, J.</a>, "<a href="http://tools.ietf.org/html/draft-reschke-http-jfv-06">A JSON Encoding for HTTP Header Field Values</a>", Internet-Draft draft-reschke-http-jfv-06, June 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="json-schema">[json-schema]</b>
      </td>
      <td class="top"><a>Wright, A.</a>, "<a href="http://tools.ietf.org/html/draft-wright-json-schema-01">JSON Schema: A Media Type for Describing JSON Documents</a>", Internet-Draft draft-wright-json-schema-01, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="json-schema-validation">[json-schema-validation]</b>
      </td>
      <td class="top"><a>Wright, A.</a>, "<a href="http://tools.ietf.org/html/draft-wright-json-schema-validation-01">JSON Schema Validation: A Vocabulary for Structural Validation of JSON</a>", Internet-Draft draft-wright-json-schema-validation-01, October 2016.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2046">[RFC2046]</b>
      </td>
      <td class="top"><a>Freed, N.</a> and <a>N. Borenstein</a>, "<a href="http://tools.ietf.org/html/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>", RFC 2046, DOI 10.17487/RFC2046, November 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4151">[RFC4151]</b>
      </td>
      <td class="top"><a>Kindberg, T.</a> and <a>S. Hawke</a>, "<a href="http://tools.ietf.org/html/rfc4151">The 'tag' URI Scheme</a>", RFC 4151, DOI 10.17487/RFC4151, October 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5789">[RFC5789]</b>
      </td>
      <td class="top"><a>Dusseault, L.</a> and <a>J. Snell</a>, "<a href="http://tools.ietf.org/html/rfc5789">PATCH Method for HTTP</a>", RFC 5789, DOI 10.17487/RFC5789, March 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5988">[RFC5988]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a>, "<a href="http://tools.ietf.org/html/rfc5988">Web Linking</a>", RFC 5988, DOI 10.17487/RFC5988, October 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6068">[RFC6068]</b>
      </td>
      <td class="top"><a>Duerst, M.</a>, <a>Masinter, L.</a> and <a>J. Zawinski</a>, "<a href="http://tools.ietf.org/html/rfc6068">The 'mailto' URI Scheme</a>", RFC 6068, DOI 10.17487/RFC6068, October 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6573">[RFC6573]</b>
      </td>
      <td class="top"><a>Amundsen, M.</a>, "<a href="http://tools.ietf.org/html/rfc6573">The Item and Collection Link Relations</a>", RFC 6573, DOI 10.17487/RFC6573, April 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7231">[RFC7231]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7807">[RFC7807]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a> and <a>E. Wilde</a>, "<a href="http://tools.ietf.org/html/rfc7807">Problem Details for HTTP APIs</a>", RFC 7807, DOI 10.17487/RFC7807, March 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.nottingham-rfc5988bis">[I-D.nottingham-rfc5988bis]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a>, "<a href="http://tools.ietf.org/html/draft-nottingham-rfc5988bis-08">Web Linking</a>", Internet-Draft draft-nottingham-rfc5988bis-08, August 2017.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#apis" id="apis">Using JSON Hyper-Schema in APIs</a></h1>
<p id="rfc.section.A.p.1">Hypermedia APIs, which follow the constraints of the REST architectural style, enable the creation of generic user agents.  Such a user agent has no application-specific knowledge.  Rather, it understands pre-defined media types, URI schemes, protocols, and link relations, often by recognizing these and coordinating the use of existing software that implements support for them.  Client applications can then be built on top of such a user agent, focusing on their own semantics and logic rather than the mechanics of the interactions.  </p>
<p id="rfc.section.A.p.2">Hyper-schema is only concerned with one resource and set of associated links at a time.  Just as a web browser works with only one HTML page at a time, with no concept of whether or how that page functions as part of a "site", a hyper-schema-aware user agent works with one resource at a time, without any concept of whether or how that resource fits into an API.  </p>
<p id="rfc.section.A.p.3">Therefore, hyper-schema is suitable for use within an API, but is not suitable for the description of APIs as complete entities in their own right.  There is no way to describe concepts at the API scope, rather than the resource and link scope, and such descriptions are outside of the boundaries of JSON Hyper-Schema.  </p>
<h1 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> Resource evolution with Hyper-Schema</h1>
<p id="rfc.section.A.1.p.1">Since a given JSON Hyper-Schema is used with a single resource at a single point in time, it has no inherent notion of versioning.  However, a given resource can change which schema or schemas it uses over time, and the URIs of these schemas can be used to indicate versioning information.  When used with a media type that supports indicating a schema with a media type parameter, these versioned schema URIs can be used in content negotiation.  </p>
<p id="rfc.section.A.1.p.2">A resource can indicate that it is an instance of multiple schemas, which allows supporting multiple compatible versions simultaneously.  A client application can then make use of the hyper-schema that it recognizes, and ignore newer or older versions.  </p>
<h1 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> Responses and errors</h1>
<p id="rfc.section.A.2.p.1">Because a hyper-schema represents a single resource at a time, it does not provide for an enumeration of all possible responses to protocol operations performed with links.  Each response, including errors, is considered its own (possibly anonymous) resource, and should identify its own hyper-schema, and optionally use an appropriate media type such as <a href="#RFC7807">RFC 7807's "application/problem+json"</a> <cite title="NONE">[RFC7807]</cite>, to allow the user agent or client application to interpret any information that is provided beyond the protocol's own status reporting.  </p>
<h1 id="rfc.appendix.A.3"><a href="#rfc.appendix.A.3">A.3.</a> <a href="#staticAnalysis" id="staticAnalysis">Static analysis of an API's hyper-schemas</a></h1>
<p id="rfc.section.A.3.p.1">It is possible to statically analyze a set of hyper-schemas without instance data in order to generate output such as documentation or code.  However, the full feature set of both validation and hyper-schema cannot be accessed without runtime instance data.  </p>
<p id="rfc.section.A.3.p.2">This is an intentional design choice to provide the maximum runtime flexibility for hypermedia systems.  JSON Schema as a media type allows for establishing additional vocabularies for static analysis and content generation, which are not addressed in this specification.  Additionally, individual systems may restrict their usage to subsets that can be analyzed statically if full design-time description is a goal.  <a id="CREF17" class="info">[CREF17]<span class="info">Vocabularies for API documentation and other purposes have been proposed, and contributions are welcome at https://github.com/json-schema-org/json-schema-vocabularies </span></a> </p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> Change Log</h1>
<p><a id="CREF18" class="info">[CREF18]<span class="info">This section to be removed before leaving Internet-Draft status.</span></a> </p>
<p/>

<dl>
  <dt>draft-TO-BE-DETERMINED-json-schema-hyperschema-NN</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>Top to bottom reorganization and rewrite</li>
      <li>Group keywords per RFC 5988bis context/relation/target/target attributes</li>
      <li>Additional keyword groups for template resolution and describing input</li>
      <li>Added section on general implementation requirements</li>
      <li>Expanded overview to provide context</li>
      <li>Consolidated HTTP guidance in its own section</li>
      <li>Added a subsection on static analysis of hyper-schemas</li>
      <li>Consolidated security concerns in their own section</li>
      <li>Added an appendix on usage in APIs</li>
      <li>Moved "readOnly" to the validation specification</li>
      <li>Moved "media" to validation as "contentMediaType"/"contentEncoding"</li>
      <li>Renamed "submissionEncType" to "submissionMediaType"</li>
      <li>Renamed "mediaType" to "targetMediaType"</li>
      <li>Added "anchor" and "anchorPointer"</li>
      <li>Added "templatePointers" and "templateRequired"</li>
      <li>Clarified how "hrefSchema" is used</li>
      <li>Added "targetHints" and "headerSchema"</li>
      <li>Added guidance on "self", "collection" and "item" link usage</li>
      <li>Added "description" as an LDO keyword</li>
      <li>Added "$comment" in LDOs to match the schema keyword</li>
    </ul>
    <p> </p>
  </dd>
  <dt>draft-wright-json-schema-hyperschema-01</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>Fixed examples</li>
      <li>Added "hrefSchema" for user input to "href" URI Templates</li>
      <li>Removed URI Template pre-processing</li>
      <li>Clarified how links and data submission work</li>
      <li>Clarified how validation keywords apply hyper-schema keywords and links</li>
      <li>Clarified HTTP use with "targetSchema"</li>
      <li>Renamed "schema" to "submissionSchema"</li>
      <li>Renamed "encType" to "submissionEncType"</li>
      <li>Removed "method"</li>
    </ul>
    <p> </p>
  </dd>
  <dt>draft-wright-json-schema-hyperschema-00</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>"rel" is now optional</li>
      <li>rel="self" no longer changes URI base</li>
      <li>Added "base" keyword to change instance URI base</li>
      <li>Removed "root" link relation</li>
      <li>Removed "create" link relation</li>
      <li>Removed "full" link relation</li>
      <li>Removed "instances" link relation</li>
      <li>Removed special behavior for "describedBy" link relation</li>
      <li>Removed "pathStart" keyword</li>
      <li>Removed "fragmentResolution" keyword</li>
      <li>Updated references to JSON Pointer, HTML</li>
      <li>Changed behavior of "method" property to align with hypermedia best current practices</li>
    </ul>
    <p> </p>
  </dd>
  <dt>draft-luff-json-hyper-schema-01</dt>
  <dd style="margin-left: 8">
    <ul>
      <li>Split from main specification.</li>
    </ul>
    <p> </p>
  </dd>
</dl>

<p> </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Henry Andrews</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Andrews</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:henry@cloudflare.com">henry@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Austin Wright</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Wright</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:aaa@bzfx.net">aaa@bzfx.net</a></span>

  </address>
</div>

</body>
</html>
